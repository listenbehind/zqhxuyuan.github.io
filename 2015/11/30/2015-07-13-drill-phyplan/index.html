	<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Apache Drill源码阅读(3) 物理计划 | 任何忧伤,都抵不过世界的美丽</title>
  <meta name="author" content="zqhxuyuan">
  
  <meta name="description" content="DrillBit各个角色:UserServer处理RUN_QUERY_VALUE客户端的查询请求,会将任务分派给UserWorker处理, 由worker提交工作:显然worker要在构造UserServer的时候也一起构造出来, 这样在收到任务的时候, 确保立即有工人接手这份工作.UserServ">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Apache Drill源码阅读(3) 物理计划"/>
  <meta property="og:site_name" content="任何忧伤,都抵不过世界的美丽"/>

  
  

  <!-- toc -->
  <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css">

  <!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">

  <!-- material design -->
	<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css">
  <!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
	<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  <!-- 百度统计 -->
  

  <!-- 谷歌统计 -->
  

  <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>
	<script>window.jQuery || document.write('<script src="/libs/jquery-2.0.3.min.js" type="text/javascript"><\/script>')</script>

</head>

 	<body>
	  <nav class="navbar navbar-default">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">菜单</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">任何忧伤,都抵不过世界的美丽</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    <a href="/" title="">
                    <i class="fa fa-home"></i>首页
                    </a>
                </li>
                
                <li>
                    <a href="/archives" title="">
                    <i class="fa fa-list"></i>存档
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</nav>

	  <div class="container" >
	    <div class="row">
	<div class="col-md-8">
	  <!-- index -->
	  
			<h1>Apache Drill源码阅读(3) 物理计划</h1>
			
			<div>
				<i class="fa fa-clock-o"></i>
				<span class="post-time">2015-11-30 09:21:35</span>
			</div>
			
	  

		<div class="content">
			<!-- index -->
		  
					<p>DrillBit各个角色:<br>UserServer处理RUN_QUERY_VALUE客户端的查询请求,会将任务分派给UserWorker处理, 由worker提交工作:<br>显然worker要在构造UserServer的时候也一起构造出来, 这样在收到任务的时候, 确保立即有工人接手这份工作.<br>UserServer的构造在ServiceEngine,而服务引擎是由DrillBit创建的.<br>UserWorker是由WorkerManager管理的, 而WorkerManager也是由DrillBit创建的.<br>所以启动DrillBit服务后,参与计算的角色都已经准备好了.  </p>
<table>
<thead>
<tr>
<th>Role</th>
<th>Explain</th>
</tr>
</thead>
<tbody>
<tr>
<td>WorkerBee</td>
<td>工蜂, 真正干活的</td>
</tr>
<tr>
<td>UserWorker</td>
<td>用户操作的(工人), 通过WorkerBee构成</td>
</tr>
<tr>
<td>WorkerManager</td>
<td>工人管理员,负责选择一个工人来工作</td>
</tr>
<tr>
<td>UserServer</td>
<td>用户操作的服务端,会将工作交给UserWorker,它需要一个UserWorker</td>
</tr>
<tr>
<td>Foreman</td>
<td>包工头,监工.由UserWorker创建出来. 因为UserWorker底层是WorkerBee,所以会将WorkerBee和Foreman关联起来</td>
</tr>
<tr>
<td>ServiceEngine</td>
<td>服务引擎,管理UserServer,Controller</td>
</tr>
<tr>
<td>DrillBit</td>
<td>Drill的服务端控制进程,管理ServiceEngine,WorkerManager</td>
</tr>
<tr>
<td>BootStrapContext</td>
<td>启动DrillBit的上下文,包括配置信息,度量注册</td>
</tr>
<tr>
<td>DrillbitContext</td>
<td>DrillBit工作时候的上下文</td>
</tr>
<tr>
<td>Controller</td>
<td>不同DrillBit节点的通信</td>
</tr>
<tr>
<td>ControllServer</td>
<td>不同节点间消息传输,连接等的RPC服务端</td>
</tr>
<tr>
<td>DataServer</td>
<td>负责数据交互的RPC服务端</td>
</tr>
</tbody>
</table>
<h3 id="工人和监工的那些事">工人和监工的那些事</h3><p>首先看下UserWorker是怎么提交一个任务的:  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> UserWorker&#123;</span><br><span class="line">  <span class="keyword">private</span> final WorkerBee bee;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> QueryId <span class="title">submitWork</span><span class="params">(UserClientConnection connection, RunQuery query)</span> </span>&#123;</span><br><span class="line">    ThreadLocalRandom r = ThreadLocalRandom.current();</span><br><span class="line">    <span class="comment">// create a new queryid where the first four bytes are a growing time (each new value comes earlier in sequence).  Last 12 bytes are random.</span></span><br><span class="line">    <span class="keyword">long</span> time = (<span class="keyword">int</span>) (System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">long</span> p1 = ((Integer.MAX_VALUE - time) &lt;&lt; <span class="number">32</span>) + r.nextInt();</span><br><span class="line">    <span class="keyword">long</span> p2 = r.nextLong();</span><br><span class="line">    QueryId id = QueryId.newBuilder().setPart1(p1).setPart2(p2).build();</span><br><span class="line">    incrementer.increment(connection.getSession());</span><br><span class="line">    Foreman foreman = <span class="keyword">new</span> Foreman(bee, bee.getContext(), connection, id, query);</span><br><span class="line">    bee.addNewForeman(foreman);</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>返回的QueryId会由UserServer通过RPC发送给客户端, 表示客户端这一次的查询标识. 服务端已经接受了这次查询.<br>但是服务端还没有开始执行这个查询任务, 后续如果客户端需要查询结果, 可以凭这个QueryId, 就可以向服务端要数据结果.  </p>
<p>WorkerBee从名字上看是工作的蜜蜂, 工蜂一直默默无闻地工作. 它为母蜂Foreman服务.<br>现在我们由UserWorker创建了一个Foreman. 工蜂把它加进来.    </p>
<blockquote>
<p>问题:<br>1.为什么不是由Foreman管理WorkerBee,而是让WorkerBee(工蜂)主动把Foreman(监工)加进来?<br>2.为什么Foreman作为一个进程,不是自己启动,而是要由工人来启动?  </p>
</blockquote>
<p>Foreman负责管理一次查询的所有fragments, Foreman会作为根节点/驱动节点  </p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Foreman manages all the fragments (local and remote) for a single query where this is the driving/root node.</span><br><span class="line"> * The flow is as follows:</span><br><span class="line"> * - Foreman is submitted as a runnable.  被提交为可执行的</span><br><span class="line"> * - Runnable does query planning. 做什么: 查询计划</span><br><span class="line"> * - state changes from PENDING to RUNNING 状态改变</span><br><span class="line"> * - Runnable sends out starting fragments 发射起始fragments</span><br><span class="line"> * - Status listener are activated 监听器被激活</span><br><span class="line"> * - The Runnable's run() completes, but the Foreman stays around 线程的run方法结束,而Foreman还停留...做什么, 看下面的</span><br><span class="line"> * - Foreman listens for state change messages. 监听状态改变的消息</span><br><span class="line"> * - state change messages can drive the state to FAILED or CANCELED, in which case 状态消息会驱动/更新Foreman的状态</span><br><span class="line"> *   messages are sent to running fragments to terminate 消息会使得正在运行的fragments终结</span><br><span class="line"> * - when all fragments complete, state change messages drive the state to COMPLETED 当所有的fragments完成后, 状态改变的消息更新Formeman的状态为已完成</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foreman</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> QueryId queryId; <span class="comment">//the id for the query</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RunQuery queryRequest; <span class="comment">//the query to execute</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> QueryContext queryContext;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> QueryManager queryManager; <span class="comment">// handles lower-level details of query execution</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> WorkerBee bee; <span class="comment">// provides an interface to submit tasks, used to submit additional work</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> DrillbitContext drillbitContext;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> UserClientConnection initiatingClient; <span class="comment">// used to send responses</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sets up the Foreman, but does not initiate any execution. 设置Foreman, 但是并没有初始化任何的执行</span></span><br><span class="line">  <span class="keyword">public</span> Foreman(<span class="keyword">final</span> WorkerBee bee, <span class="keyword">final</span> DrillbitContext drillbitContext, <span class="keyword">final</span> UserClientConnection connection, <span class="keyword">final</span> QueryId queryId, <span class="keyword">final</span> RunQuery queryRequest) &#123;</span><br><span class="line">    <span class="keyword">this</span>.bee = bee;</span><br><span class="line">    <span class="keyword">this</span>.queryId = queryId;</span><br><span class="line">    <span class="keyword">this</span>.queryRequest = queryRequest;</span><br><span class="line">    <span class="keyword">this</span>.drillbitContext = drillbitContext;</span><br><span class="line">    <span class="keyword">this</span>.initiatingClient = connection;</span><br><span class="line">    <span class="keyword">this</span>.closeFuture = initiatingClient.getChannel().closeFuture();</span><br><span class="line">    closeFuture.addListener(closeListener);</span><br><span class="line">    queryContext = <span class="keyword">new</span> QueryContext(connection.getSession(), drillbitContext);</span><br><span class="line">    queryManager = <span class="keyword">new</span> QueryManager(queryId, queryRequest, drillbitContext.getPersistentStoreProvider(), stateListener, <span class="keyword">this</span>);</span><br><span class="line">    recordNewState(QueryState.PENDING);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Foreman的run方法根据RunQuery的类型执行不同的方法,比如SQL类型,则要负责将SQL语句通过Calcite解析成逻辑计划,生成物理计划,最后运行物理计划.  </p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> runSQL(<span class="keyword">final</span> <span class="keyword">String</span> sql) <span class="keyword">throws</span> ExecutionSetupException &#123;</span><br><span class="line">  <span class="keyword">final</span> DrillSqlWorker sqlWorker = <span class="keyword">new</span> DrillSqlWorker(queryContext);</span><br><span class="line">  <span class="keyword">final</span> Pointer&lt;<span class="keyword">String</span>&gt; textPlan = <span class="keyword">new</span> Pointer&lt;&gt;();</span><br><span class="line">  <span class="keyword">final</span> PhysicalPlan plan = sqlWorker.getPlan(sql, textPlan);</span><br><span class="line">  queryManager.setPlanText(textPlan.value);</span><br><span class="line">  runPhysicalPlan(plan);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="SQL_Parser">SQL Parser</h3><p>Calcite的planner对SQL进行parse解析, 生成SqlNode节点,  对于不同的SqlNode类型, 由不同的Handler进行进行解析.   </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrillSqlWorker</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Planner planner;  <span class="comment">//这两个Planner都是Calcite的,负责解析成逻辑计划</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HepPlanner hepPlanner;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> QueryContext context;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function">PhysicalPlan <span class="title">getPlan</span><span class="params">(String sql, Pointer&lt;String&gt; textPlan)</span> <span class="keyword">throws</span> ForemanSetupException </span>&#123;</span><br><span class="line">    SqlNode sqlNode = planner.parse(sql);  <span class="comment">//将SQL语句解析成SqlNode解析树①</span></span><br><span class="line">    AbstractSqlHandler <span class="keyword">handler</span>;</span><br><span class="line">    SqlHandlerConfig config = <span class="keyword">new</span> SqlHandlerConfig(hepPlanner, planner, context);</span><br><span class="line">    <span class="keyword">switch</span>(sqlNode.getKind())&#123;</span><br><span class="line">    <span class="keyword">case</span> EXPLAIN:</span><br><span class="line">      <span class="keyword">handler</span> = <span class="keyword">new</span> ExplainHandler(config);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SET_OPTION:</span><br><span class="line">      <span class="keyword">handler</span> = <span class="keyword">new</span> SetOptionHandler(context);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OTHER:</span><br><span class="line">      <span class="keyword">if</span>(sqlNode <span class="keyword">instanceof</span> SqlCreateTable) &#123;</span><br><span class="line">        <span class="keyword">handler</span> = ((DrillSqlCall)sqlNode).getSqlHandler(config, textPlan);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (sqlNode <span class="keyword">instanceof</span> DrillSqlCall) &#123;</span><br><span class="line">        <span class="keyword">handler</span> = ((DrillSqlCall)sqlNode).getSqlHandler(config);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">handler</span> = <span class="keyword">new</span> DefaultSqlHandler(config, textPlan);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="keyword">handler</span>.<span class="title">getPlan</span><span class="params">(sqlNode)</span></span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The Drillbit that receives the query from a client or application becomes the Foreman for the query and drives the entire query.<br>A parser in the Foreman parses the SQL[①], applying custom rules[②] to convert specific SQL operators into a specific logical operator syntax that Drill understands.<br>This collection of logical operators forms a logical plan. The logical plan describes the work required to generate the query results and defines what data sources and operations to apply.  </p>
<p>Foreman中的parser解析SQL, 并运用定制的规则, 将SQL操作符(Calcite的节点)转换成Drill认识的逻辑操作符(Drill的节点DrillRel).<br>转换后的逻辑操作符集合会组成一个逻辑计划.  注意上面的sqlNode=planner.parse(sql)对应的是SQL操作符, 转换成DrillRelNode在Handler的getPlan中完成.  </p>
</blockquote>
<h3 id="SqlNode(Calcite_SQL操作符)">SqlNode(Calcite SQL操作符)</h3><p>Calcite的编程API主要包括了: Operator, Rule, RelationExpression, SqlNode.  </p>
<p><img src="http://7xjs7x.com1.z0.glb.clouddn.com/calcite1.png" alt=""></p>
<h3 id="What’s_Rule?">What’s Rule?</h3><p>Calcite的planner对SQL进行parse解析, 除了用到Calcite自身的一些规则外, Drill也会附加一些规则getRules给它. 定义在DrillSqlWorker的构造函数中.<br>规则包括物理计划, 逻辑计划, 转换规则.  其中逻辑计划包括基本规则,用户自定义规则. 物理计划包括物理规则,存储插件的规则. 比如hive插件有自己的SQL执行转换规则.  </p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="component">public DrillSqlWorker(QueryContext context) &#123;</span><br><span class="line">  FrameworkConfig config = Frameworks<span class="string">.newConfigBuilder()</span> ...</span><br><span class="line">      <span class="string">.ruleSets(getRules(context))...</span>  //Drill附加的规则②</span><br><span class="line">      <span class="string">.build()</span>;</span><br><span class="line">  this<span class="string">.planner</span> = Frameworks<span class="string">.getPlanner(config)</span>;    </span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="component">private RuleSet[] getRules(QueryContext context) &#123;</span><br><span class="line">  StoragePluginRegistry storagePluginRegistry = context<span class="string">.getStorage()</span>;</span><br><span class="line">  RuleSet drillLogicalRules = DrillRuleSets<span class="string">.mergedRuleSets(DrillRuleSets.getDrillBasicRules(context)</span>, DrillRuleSets<span class="string">.getJoinPermRules(context)</span>, DrillRuleSets<span class="string">.getDrillUserConfigurableLogicalRules(context))</span>;</span><br><span class="line">  RuleSet drillPhysicalMem = DrillRuleSets<span class="string">.mergedRuleSets(DrillRuleSets.getPhysicalRules(context)</span>, storagePluginRegistry<span class="string">.getStoragePluginRuleSet())</span>;</span><br><span class="line">  // Following is used in LOPT join OPT.</span><br><span class="line">  RuleSet logicalConvertRules = DrillRuleSets<span class="string">.mergedRuleSets(DrillRuleSets.getDrillBasicRules(context)</span>, DrillRuleSets<span class="string">.getDrillUserConfigurableLogicalRules(context))</span>;</span><br><span class="line">  RuleSet[] allRules = new RuleSet[] &#123;drillLogicalRules, drillPhysicalMem, logicalConvertRules&#125;</span>;</span><br><span class="line">  return allRules;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑计划的基本规则, 这些规则是通用的, 不需要在物理计划阶段完成, 通用的规则尽早做.  </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get an immutable list of rules that will always be used when running logical planning.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">RuleSet <span class="title">getDrillBasicRules</span><span class="params">(QueryContext context)</span> </span>&#123;</span><br><span class="line">    DRILL_BASIC_RULES = <span class="keyword">new</span> DrillRuleSet(ImmutableSet.&lt;RelOptRule&gt; builder().add( <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Add support for Distinct Union (by using Union-All followed by Distinct)</span></span><br><span class="line">    UnionToDistinctRule.INSTANCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add support for WHERE style joins. 添加支持where类型的join</span></span><br><span class="line">    DrillFilterJoinRules.DRILL_FILTER_ON_JOIN,</span><br><span class="line">    DrillFilterJoinRules.DRILL_JOIN,</span><br></pre></td></tr></table></figure>
<p>举个where类型的join规则转换: <a href="http://blog.aliyun.com/733" target="_blank" rel="external">http://blog.aliyun.com/733</a><br>SELECT * FROM A JOIN B ON A.ID=B.ID WHERE A.AGE&gt;10 AND B.AGE&gt;5<br><code>Predict Push Down</code>: 在遇有JOIN运算时,用户很有可能还要在JOIN之后做WHERE运算,此时就要从代数逻辑上分析,<br>WHERE中计算的条件是否可以被提前到JOIN之前运算,以此来减少JOIN运算的数据量,提升效率  </p>
<p><img src="http://7xjs7x.com1.z0.glb.clouddn.com/drill17.png" alt=""></p>
<p>那么Drill的FilterJoin规则是怎么样的呢?  </p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> DrillFilterJoinRules &#123;</span><br><span class="line">  <span class="comment">/** Predicate that always returns true for any filter in OUTER join, and only true for EQUAL or IS_DISTINCT_FROM over RexInputRef in INNER join.</span><br><span class="line">   * With this predicate, the filter expression that return true will be kept in the JOIN OP.</span><br><span class="line">   * Example:  INNER JOIN,   L.C1 = R.C2 and L.C3 + 100 = R.C4 + 100 will be kepted in JOIN.</span><br><span class="line">   *                         L.C5 &lt; R.C6 will be pulled up into Filter above JOIN. </span><br><span class="line">   *           OUTER JOIN,   Keep any filter in JOIN.</span><br><span class="line">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FilterJoinRule.Predicate EQUAL_IS_DISTINCT_FROM =</span><br><span class="line">      <span class="keyword">new</span> FilterJoinRule.Predicate() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> apply(<span class="keyword">Join</span> <span class="keyword">join</span>, JoinRelType joinType, RexNode exp) &#123;</span><br><span class="line">          <span class="comment">// In OUTER join, we could not pull-up the filter. All we can do is keep the filter with JOIN, and then decide whether the filter could be pushed down into LEFT/RIGHT.</span></span><br><span class="line">          <span class="keyword">if</span> (joinType != JoinRelType.INNER) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          List&lt;RexNode&gt; tmpLeftKeys = Lists.newArrayList();</span><br><span class="line">          List&lt;RexNode&gt; tmpRightKeys = Lists.newArrayList();</span><br><span class="line">          List&lt;RelDataTypeField&gt; sysFields = Lists.newArrayList();</span><br><span class="line">          RexNode remaining = RelOptUtil.splitJoinCondition(sysFields, <span class="keyword">join</span>.getLeft(), <span class="keyword">join</span>.getRight(), exp, tmpLeftKeys, tmpRightKeys, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (remaining.isAlwaysTrue())  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Rule that pushes predicates from a Filter into the Join below them. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FilterJoinRule DRILL_FILTER_ON_JOIN =</span><br><span class="line">      <span class="keyword">new</span> FilterJoinRule.FilterIntoJoinRule(<span class="keyword">true</span>, RelFactories.DEFAULT_FILTER_FACTORY,</span><br><span class="line">          RelFactories.DEFAULT_PROJECT_FACTORY, EQUAL_IS_DISTINCT_FROM);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里最好要理解下Calcite的一些概念, 要不然理解起来有一定困难.<br>参考<a href="http://blog.csdn.net/yunlong34574/article/details/46375733" target="_blank" rel="external">http://blog.csdn.net/yunlong34574/article/details/46375733</a>了解下optiq-javaben这个项目的源码.<br>然后参考这里了解下查询下推优化:<a href="https://datapsyche.wordpress.com/2014/08/06/optiq-query-push-down-concept" target="_blank" rel="external">https://datapsyche.wordpress.com/2014/08/06/optiq-query-push-down-concept</a>  </p>
</blockquote>
<h3 id="Calcite_FilterJoinRule">Calcite FilterJoinRule</h3><p>下面引用了Optiq作者的Apache Calcite Overview的一个示例:  </p>
<p>两张表进行join后有一个where过滤条件, 没有使用规则的话, 则要join完后才进行过滤:  </p>
<p><img src="http://7xjs7x.com1.z0.glb.clouddn.com/calcite2.png" alt=""></p>
<p>使用FilterJoinRule后, 把Filter提前到Join之前, 扫描之后立刻进行, 这样减少了join的数据量:  </p>
<p><img src="http://7xjs7x.com1.z0.glb.clouddn.com/calcite3.png" alt=""></p>
<p>那么怎么定义一个规则呢?  cal.rels是一个RelationExpression数组, 调用onMatch时, rels=[Join,Filter,Scan]<br>因此我们要获得call.rels中的Join和Filter. 使用数组索引rel(0)表示Join, rel(1)表示Filter.<br>最后调用call.transform(newJoin)将原始的RelationExpression转换成新的RelExp.  </p>
<p><img src="http://7xjs7x.com1.z0.glb.clouddn.com/calcite4.png" alt=""></p>
<blockquote>
<p>注意转换后的右图Join’,Filter’上面的引号表示new. 和原来的Join,Filter是不一样的变量了.  </p>
</blockquote>
<p>这里我们进入Calcite的源码看看它是怎么做的. 内部类FilterIntoJoinRule的构造函数参数:  </p>
<p>filterFactory和projectFactory分别是FilterFactoryImpl,ProjectFactoryImpl.<br>作为工厂类,它们的create方法会调用LogicalFilter,LogicalProject的create方法返回RelNode.  </p>
<p>那么问题是这里传入的为什么是Filter和Project呢? Filter显然需要,因为我们的规则就是针对Filter和Join进行优化的.<br>Project呢? Filter肯定是针对某个字段进行过滤的, 这里的过滤字段就可以认为是先Project把结果查出来,才有机会进行过滤.  </p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Rule that tries to push filter expressions into a join condition and into the inputs of the join. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> FilterIntoJoinRule <span class="keyword">extends</span> FilterJoinRule &#123;</span><br><span class="line">  <span class="keyword">public</span> FilterIntoJoinRule(<span class="keyword">boolean</span> smart, RelFactories.FilterFactory filterFactory, RelFactories.ProjectFactory projectFactory, Predicate predicate) &#123;</span><br><span class="line">    <span class="keyword">super</span>(</span><br><span class="line">        operand(Filter.<span class="keyword">class</span>,</span><br><span class="line">            operand(<span class="keyword">Join</span>.<span class="keyword">class</span>, RelOptRule.<span class="keyword">any</span>())),</span><br><span class="line">        <span class="string">"FilterJoinRule:filter"</span>, smart, filterFactory, projectFactory, predicate);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override <span class="keyword">public</span> <span class="keyword">void</span> onMatch(RelOptRuleCall <span class="keyword">call</span>) &#123;</span><br><span class="line">    Filter filter = <span class="keyword">call</span>.rel(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">Join</span> <span class="keyword">join</span> = <span class="keyword">call</span>.rel(<span class="number">1</span>);</span><br><span class="line">    perform(<span class="keyword">call</span>, filter, <span class="keyword">join</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onMatch方法和上面的图是一样的. 而具体的call.transform则在FilterJoinRule的perform中完成.  我们先看下FilterIntoJoinRule类上面的注释:<br>尝试着把filter表达式push到一个join条件里面, 并且push到join的输入. 假设join的输入是Scan,则filer会push到Scan后面.  </p>
<p>再来看看FilterJoinRule类上面的注释: <code>Planner rule that pushes filters above and within a join node into the join node and/or its children nodes.</code> </p>
<p>向上提升filters(为什么是向上, 向上向下的方向是什么? Scan是输入源,则Scan在上, Scan-Join-Filter转换为Scan-Filter-Join,则Filter向上提升了一个等级),<br>within表示在一个join节点内部, 原先是Scan-Join-Filter, 第一步是把Filter合并到Join里面: Scan-Join(Filter)<br>或者join节点的子节点, 从Tree的角度来看, Join下面是两张数据源表,数据源就是Join的children节点.<br>我们可以把Filterwithin到Join的孩子节点即Scan中. 即第二步就是: Scan(Filter)-Join. DAG图就是: Scan-Filter-Join. Wow!!!</p>
<p>1.把left,right表解析出来即join.left,join.right. 以及leftFitlers,rightFilters.<br>2.根据leftFilters和left, rightFilters和right创建新的leftRel,rightRel节点<br>3.创建新的join节点,并且引用新的孩子节点(即上面的leftRel,rightRel)<br>4.调用call的transformTo,参数是最新的join节点.   </p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// create FilterRels on top of the children if any filters were pushed to them</span></span><br><span class="line">  <span class="keyword">final</span> RexBuilder rexBuilder = <span class="keyword">join</span>.getCluster().getRexBuilder();</span><br><span class="line">  RelNode leftRel = RelOptUtil.createFilter(<span class="keyword">join</span>.getLeft(), leftFilters, filterFactory);</span><br><span class="line">  RelNode rightRel = RelOptUtil.createFilter(<span class="keyword">join</span>.getRight(), rightFilters, filterFactory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create the new join node referencing the new children and containing its new join filters (if there are any)</span></span><br><span class="line">  <span class="keyword">final</span> RexNode joinFilter = RexUtil.composeConjunction(rexBuilder, joinFilters, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  RelNode newJoinRel = <span class="keyword">join</span>.<span class="keyword">copy</span>(<span class="keyword">join</span>.getTraitSet(), joinFilter, leftRel, rightRel, joinType, <span class="keyword">join</span>.isSemiJoinDone());</span><br><span class="line">  <span class="keyword">call</span>.getPlanner().onCopy(<span class="keyword">join</span>, newJoinRel);</span><br><span class="line">  <span class="keyword">if</span> (!leftFilters.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">call</span>.getPlanner().onCopy(filter, leftRel);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!rightFilters.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">call</span>.getPlanner().onCopy(filter, rightRel);</span><br><span class="line">  &#125;        </span><br><span class="line"></span><br><span class="line">  <span class="comment">// create a FilterRel on top of the join if needed</span></span><br><span class="line">  RelNode newRel = RelOptUtil.createFilter(newJoinRel,</span><br><span class="line">          RexUtil.fixUp(rexBuilder, aboveFilters, newJoinRel.getRowType()),</span><br><span class="line">          filterFactory);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">call</span>.transformTo(newRel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们实现了自定义规则的onMatch方法, 那么谁来调用它呢:   </p>
<p>RelOptPlanner实现类VolcanoPlanner.fireRules-&gt;RelOptRule的实现类VolcanoRuleCall.match-&gt;matchRecurse-&gt;onMatch-&gt;getRule().onMatch(this);  </p>
<blockquote>
<p>Volcano的意思是火山似的,猛烈的. 由此说明规则很多的话, match调用会是很凶猛的. </p>
</blockquote>
<h3 id="Drill_FilterJoin_Example">Drill FilterJoin Example</h3><p>执行下面的SQL语句, 第一次不加where,第二次添加where过滤条件, 第三次where是字段比较</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">FROM</span> dfs.`<span class="regexp">/home/</span>hadoop<span class="regexp">/soft/</span>apache-drill-<span class="number">1.0</span>.<span class="number">0</span><span class="regexp">/sample-data/</span>nation.parquet` nations</span><br><span class="line"><span class="keyword">join</span> dfs.`<span class="regexp">/home/</span>hadoop<span class="regexp">/soft/</span>apache-drill-<span class="number">1.0</span>.<span class="number">0</span><span class="regexp">/sample-data/</span>region.parquet` regions</span><br><span class="line">on nations.N_REGIONKEY = regions.R_REGIONKEY</span><br><span class="line"></span><br><span class="line">select * <span class="keyword">FROM</span> dfs.`<span class="regexp">/home/</span>hadoop<span class="regexp">/soft/</span>apache-drill-<span class="number">1.0</span>.<span class="number">0</span><span class="regexp">/sample-data/</span>nation.parquet` nations</span><br><span class="line"><span class="keyword">join</span> dfs.`<span class="regexp">/home/</span>hadoop<span class="regexp">/soft/</span>apache-drill-<span class="number">1.0</span>.<span class="number">0</span><span class="regexp">/sample-data/</span>region.parquet` regions</span><br><span class="line">on nations.N_REGIONKEY = regions.R_REGIONKEY</span><br><span class="line">where nations.N_NATIONKEY&gt;<span class="number">10</span> and regions.R_NAME=<span class="string">'AMERICA'</span></span><br><span class="line"></span><br><span class="line">select * <span class="keyword">FROM</span> dfs.`<span class="regexp">/home/</span>hadoop<span class="regexp">/soft/</span>apache-drill-<span class="number">1.0</span>.<span class="number">0</span><span class="regexp">/sample-data/</span>nation.parquet` nations</span><br><span class="line"><span class="keyword">join</span> dfs.`<span class="regexp">/home/</span>hadoop<span class="regexp">/soft/</span>apache-drill-<span class="number">1.0</span>.<span class="number">0</span><span class="regexp">/sample-data/</span>region.parquet` regions</span><br><span class="line">on nations.N_REGIONKEY = regions.R_REGIONKEY</span><br><span class="line">where nations.N_NAME&lt;regions.R_NAME</span><br></pre></td></tr></table></figure>
<p>下面是对应物理计划可视化图, 图1在Scan和JOIN之间有Project:  </p>
<p><img src="http://7xjs7x.com1.z0.glb.clouddn.com/drill18.png" alt="">   </p>
<p>图2虽然where过滤在join之后, 但是经过优化后, 会先于join执行的: 即filter之后才进行join  </p>
<p><img src="http://7xjs7x.com1.z0.glb.clouddn.com/drill19.png" alt="">   </p>
<p>图3就没这么幸运了,要在join之后才能filter.</p>
<p><img src="http://7xjs7x.com1.z0.glb.clouddn.com/drill20.png" alt="">   </p>
<hr>
<h3 id="DrillRel(Drill逻辑操作符)">DrillRel(Drill逻辑操作符)</h3><p>getPlan的参数SqlNode在前面通过Calcite的解析, 结果是一颗SQL parse tree(不要以为Node就只有一个节点),<br>但它还只是Calcite认识的SQL操作符, 我们要将它转换为Drill能够认识的逻辑操作符即DrillRel.  </p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public PhysicalPlan getPlan(SqlNode sqlNode) throws ValidationException, RelConversionException, IOException, ForemanSetupException &#123;</span><br><span class="line">  SqlNode rewrittenSqlNode = rewrite(sqlNode)<span class="comment">;</span></span><br><span class="line">  TypedSqlNode validatedTypedSqlNode = validateNode(rewrittenSqlNode)<span class="comment">;</span></span><br><span class="line">  SqlNode validated = validatedTypedSqlNode.getSqlNode()<span class="comment">;</span></span><br><span class="line">  RelDataType validatedRowType = validatedTypedSqlNode.getType()<span class="comment">;</span></span><br><span class="line">  RelNode rel = convertToRel(validated)<span class="comment">;</span></span><br><span class="line">  rel = preprocessNode(rel)<span class="comment">;</span></span><br><span class="line">  log("Optiq Logical", rel)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  DrillRel drel = convertToDrel(rel, validatedRowType)<span class="comment">;</span></span><br><span class="line">  log("Drill Logical", drel)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  Prel prel = convertToPrel(drel)<span class="comment">;</span></span><br><span class="line">  log("Drill Physical", prel)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  PhysicalOperator pop = convertToPop(prel)<span class="comment">;</span></span><br><span class="line">  PhysicalPlan plan = convertToPlan(pop)<span class="comment">;</span></span><br><span class="line">  log("Drill Plan", plan)<span class="comment">;</span></span><br><span class="line">  return plan<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Relational Expression(Rel)</strong></p>
<p>在查询过程中也说了: <code>执行计划总是包含一个Screen Operator,用来阻塞并且等待返回的数据. 返回的DrillRel就是逻辑计划.</code><br>SqlNode,RelNode是Calcite的节点, DrillRel是Drill的关系表达式节点,在最外层包装了一个Screen用于屏幕输出.    </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function">DrillRel <span class="title">convertToDrel</span><span class="params">(RelNode relNode, RelDataType validatedRowType)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Put a non-trivial topProject to ensure the final output field name is preserved, when necessary.</span></span><br><span class="line">      DrillRel topPreservedNameProj = addRenamedProject((DrillRel) convertedRelNode, validatedRowType);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DrillScreenRel(topPreservedNameProj.getCluster(), topPreservedNameProj.getTraitSet(), topPreservedNameProj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Screen Node和其他一些DrillRel的构造函数, 其中input指定了Screen的输入,表示用Screen节点包装上原先的节点, 使其成为一个新的节点.  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DrillScreenRel</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">DrillScreenRelBase</span> <span class="title">implements</span> <span class="title">DrillRel</span> &#123;</span></span><br><span class="line">  public <span class="type">DrillScreenRel</span>(<span class="type">RelOptCluster</span> cluster, <span class="type">RelTraitSet</span> traitSet, <span class="type">RelNode</span> input) &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="type">DRILL_LOGICAL</span>, cluster, traitSet, input);</span><br><span class="line">  &#125;</span><br><span class="line">  public <span class="type">LogicalOperator</span> implement(<span class="type">DrillImplementor</span> implementor) &#123;</span><br><span class="line">    <span class="type">LogicalOperator</span> childOp = implementor.visitChild(<span class="keyword">this</span>, <span class="number">0</span>, getInput());</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Store</span>.builder().setInput(childOp).storageEngine(<span class="string">"--SCREEN--"</span>).build();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>类继承关系: DrillScreenRel &gt;&gt; DrillRel &gt;&gt; DrillRelNode &gt;&gt; RelNode<br>其中DrillRel是逻辑计划的关系表达式. 子类要实现implement方法, 返回逻辑操作符.  </p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Relational expression that is implemented in Drill.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DrillRel</span> <span class="keyword">extends</span> <span class="title">DrillRelNode</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Calling convention for relational expressions that are "implemented" by generating Drill logical plans</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Convention DRILL_LOGICAL = <span class="keyword">new</span> Convention.Impl(<span class="string">"LOGICAL"</span>, DrillRel.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">  LogicalOperator implement(DrillImplementor implementor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://7xjs7x.com1.z0.glb.clouddn.com/drill13-2.png" alt="">  <img src="http://7xjs7x.com1.z0.glb.clouddn.com/drill13-1.png" alt=""></p>
<h3 id="DrillRel_Nodes_Tree_→_Drill_LogicalPlan">DrillRel Nodes Tree → Drill LogicalPlan</h3><p>DrillImplementor: <code>Context for converting a tree of DrillRel nodes into a Drill logical plan</code>  </p>
<h3 id="物理计划Prel">物理计划Prel</h3><p>然后将逻辑计划转换为物理计划, 将DrillRel转换为Prel. 最后才是Drill的Plan. 注意Drill的物理计划和最终的Plan是有点差别的.  </p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="type">Prel</span> convertToPrel(<span class="type">RelNode</span> drel) &#123;</span><br><span class="line">  <span class="type">Prel</span> phyRelNode = (<span class="type">Prel</span>) planner.transform(<span class="type">DrillSqlWorker</span>.<span class="type">PHYSICAL_MEM_RULES</span>, traits, drel);</span><br><span class="line"></span><br><span class="line">  /*  <span class="type">The</span> order <span class="keyword">of</span> the following transformation <span class="keyword">is</span> important */</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">   * <span class="number">0</span>.) <span class="type">For</span> select * <span class="keyword">from</span> join query, we need insert project on top <span class="keyword">of</span> scan <span class="keyword">and</span> a top project just</span><br><span class="line">   * under screen operator. <span class="type">The</span> project on top <span class="keyword">of</span> scan will rename <span class="keyword">from</span> * to <span class="type">T1</span>*, <span class="keyword">while</span> the top project</span><br><span class="line">   * will rename <span class="type">T1</span>* to *, before it output the final <span class="literal">result</span>. <span class="type">Only</span> the top project will allow</span><br><span class="line">   * duplicate columns, since user could <span class="string">"explicitly"</span> ask <span class="keyword">for</span> duplicate columns ( select *, col, *).</span><br><span class="line">   * <span class="type">The</span> rest <span class="keyword">of</span> projects will remove the duplicate column <span class="keyword">when</span> we generate <span class="type">POP</span> <span class="keyword">in</span> json format.</span><br><span class="line">   */</span><br><span class="line">  phyRelNode = <span class="type">StarColumnConverter</span>.insertRenameProject(phyRelNode);  //* <span class="keyword">is</span> star, <span class="keyword">and</span> this column should convert</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换的过程比较复杂, 而且转换的顺序也很重要. 先看第一个, 在select * from join这种情况下, 要插入两个Project.<br>一个是scan(bottom)之上, 一个是screen(top)之下. 比如下面的SQL语句:    </p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select <span class="keyword">*</span> from dfs.`/usr/install/apache-drill-1.1.0/sample-data/nation.parquet` nations</span><br><span class="line">join dfs.`/usr/install/apache-drill-1.1.0/sample-data/region.parquet` regions</span><br><span class="line">on nations.N_REGIONKEY = regions.R_REGIONKEY;</span><br><span class="line">+--------------+-----------------+--------------+-----------------------+--------------+--------------+-----------------------+</span><br><span class="line">|<span class="string"> N_NATIONKEY  </span>|<span class="string">     N_NAME      </span>|<span class="string"> N_REGIONKEY  </span>|<span class="string">       N_COMMENT       </span>|<span class="string"> R_REGIONKEY  </span>|<span class="string">    R_NAME    </span>|<span class="string">       R_COMMENT       </span>|</span><br><span class="line">+--------------+-----------------+--------------+-----------------------+--------------+--------------+-----------------------+</span><br><span class="line">|<span class="string"> 0            </span>|<span class="string"> ALGERIA         </span>|<span class="string"> 0            </span>|<span class="string">  haggle. carefully f  </span>|<span class="string"> 0            </span>|<span class="string"> AFRICA       </span>|<span class="string"> lar deposits. blithe  </span>|</span><br><span class="line">|<span class="string"> 1            </span>|<span class="string"> ARGENTINA       </span>|<span class="string"> 1            </span>|<span class="string"> al foxes promise sly  </span>|<span class="string"> 1            </span>|<span class="string"> AMERICA      </span>|<span class="string"> hs use ironic, even   </span>|</span><br></pre></td></tr></table></figure>
<p>物理计划: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>-<span class="number">00</span>    Screen : rowType = RecordType(ANY *, ANY *<span class="number">0</span>): rowcount = <span class="number">25.0</span>, cumulative cost = &#123;<span class="number">62.5</span> rows, <span class="number">402.5</span> cpu, <span class="number">0.0</span> io, <span class="number">0.0</span> network, <span class="number">88.0</span> memory&#125;, id = <span class="number">2432</span></span><br><span class="line"><span class="number">00</span>-<span class="number">01</span>   ⑤ ProjectAllowDup(*=[$<span class="number">0</span>], *<span class="number">0</span>=[$<span class="number">1</span>]) : rowType = RecordType(ANY *, ANY *<span class="number">0</span>): rowcount = <span class="number">25.0</span>, cumulative cost = &#123;<span class="number">60.0</span> rows, <span class="number">400.0</span> cpu, <span class="number">0.0</span> io, <span class="number">0.0</span> network, <span class="number">88.0</span> memory&#125;, id = <span class="number">2431</span></span><br><span class="line"><span class="number">00</span>-<span class="number">02</span>   ④   Project(T0¦¦*=[$<span class="number">0</span>], T1¦¦*=[$<span class="number">2</span>]) : rowType = RecordType(ANY T0¦¦*, ANY T1¦¦*): rowcount = <span class="number">25.0</span>, cumulative cost = &#123;<span class="number">60.0</span> rows, <span class="number">400.0</span> cpu, <span class="number">0.0</span> io, <span class="number">0.0</span> network, <span class="number">88.0</span> memory&#125;, id = <span class="number">2430</span></span><br><span class="line"><span class="number">00</span>-<span class="number">03</span>   ③     HashJoin(condition=[=($<span class="number">1</span>, $<span class="number">3</span>)], joinType=[inner]) : rowType = RecordType(ANY T0¦¦*, ANY N_REGIONKEY, ANY T1¦¦*, ANY R_REGIONKEY): rowcount = <span class="number">25.0</span>, cumulative cost = &#123;<span class="number">60.0</span> rows, <span class="number">400.0</span> cpu, <span class="number">0.0</span> io, <span class="number">0.0</span> network, <span class="number">88.0</span> memory&#125;, id = <span class="number">2429</span></span><br><span class="line"><span class="number">00</span>-<span class="number">05</span>   ①       Project(T0¦¦*=[$<span class="number">0</span>], N_REGIONKEY=[$<span class="number">1</span>]) : rowType = RecordType(ANY T0¦¦*, ANY N_REGIONKEY): rowcount = <span class="number">25.0</span>, cumulative cost = &#123;<span class="number">25.0</span> rows, <span class="number">50.0</span> cpu, <span class="number">0.0</span> io, <span class="number">0.0</span> network, <span class="number">0.0</span> memory&#125;, id = <span class="number">2426</span></span><br><span class="line"><span class="number">00</span>-<span class="number">07</span>              Scan(groupscan=[ParquetGroupScan [entries=[ReadEntryWithPath [path=file:/usr/install/apache-drill-<span class="number">1.1</span><span class="number">.0</span>/sample-data/nation.parquet]], selectionRoot=file:/usr/install/apache-drill-<span class="number">1.1</span><span class="number">.0</span>/sample-data/nation.parquet, numFiles=<span class="number">1</span>, columns=[`*`]]]) : rowType = (DrillRecordRow[*, N_REGIONKEY]): rowcount = <span class="number">25.0</span>, cumulative cost = &#123;<span class="number">25.0</span> rows, <span class="number">50.0</span> cpu, <span class="number">0.0</span> io, <span class="number">0.0</span> network, <span class="number">0.0</span> memory&#125;, id = <span class="number">2425</span></span><br><span class="line"><span class="number">00</span>-<span class="number">04</span>   ②       Project(T1¦¦*=[$<span class="number">0</span>], R_REGIONKEY=[$<span class="number">1</span>]) : rowType = RecordType(ANY T1¦¦*, ANY R_REGIONKEY): rowcount = <span class="number">5.0</span>, cumulative cost = &#123;<span class="number">5.0</span> rows, <span class="number">10.0</span> cpu, <span class="number">0.0</span> io, <span class="number">0.0</span> network, <span class="number">0.0</span> memory&#125;, id = <span class="number">2428</span></span><br><span class="line"><span class="number">00</span>-<span class="number">06</span>              Scan(groupscan=[ParquetGroupScan [entries=[ReadEntryWithPath [path=file:/usr/install/apache-drill-<span class="number">1.1</span><span class="number">.0</span>/sample-data/region.parquet]], selectionRoot=file:/usr/install/apache-drill-<span class="number">1.1</span><span class="number">.0</span>/sample-data/region.parquet, numFiles=<span class="number">1</span>, columns=[`*`]]]) : rowType = (DrillRecordRow[*, R_REGIONKEY]): rowcount = <span class="number">5.0</span>, cumulative cost = &#123;<span class="number">5.0</span> rows, <span class="number">10.0</span> cpu, <span class="number">0.0</span> io, <span class="number">0.0</span> network, <span class="number">0.0</span> memory&#125;, id = <span class="number">2427</span></span><br></pre></td></tr></table></figure>
<p>对应的可视化图:  </p>
<p><img src="http://7xjs7x.com1.z0.glb.clouddn.com/drill14.png" alt=""></p>
<p>物理计划中的$0, $1…这些数字代表的是as后的变量,如果是join有可能列名相同,所以也要添加project重命名防止名称冲突:    </p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">① select T<span class="number">0</span>.* <span class="keyword">as</span> <span class="variable">$0</span>, T<span class="number">0</span>.N_REGIONKEY <span class="keyword">as</span> <span class="variable">$1</span> from nations T<span class="number">0</span> </span><br><span class="line">② select T1.* <span class="keyword">as</span> <span class="variable">$0</span>, T1.R_REGIONKEY <span class="keyword">as</span> <span class="variable">$1</span> from regions T1</span><br><span class="line">③ select T<span class="number">0</span>.<span class="variable">$0</span> <span class="keyword">as</span> <span class="variable">$0</span>, T<span class="number">0</span>.<span class="variable">$1</span> <span class="keyword">as</span> <span class="variable">$1</span>, T1.<span class="variable">$0</span> <span class="keyword">as</span> <span class="variable">$2</span>, T1.<span class="variable">$1</span> <span class="keyword">as</span> <span class="variable">$3</span> </span><br><span class="line">   from (select T<span class="number">0</span>.<span class="variable">$0</span> <span class="keyword">as</span> <span class="variable">$0</span>, T<span class="number">0</span>.<span class="variable">$1</span> <span class="keyword">as</span> <span class="variable">$1</span> from nations) T<span class="number">0</span></span><br><span class="line">   join (select T1.<span class="variable">$0</span> <span class="keyword">as</span> <span class="variable">$2</span>, T1.<span class="variable">$1</span> <span class="keyword">as</span> <span class="variable">$3</span> from regions) T1</span><br><span class="line">   on T<span class="number">0</span>.<span class="variable">$1</span> = T1.<span class="variable">$3</span> </span><br><span class="line">④ select <span class="variable">$0</span> <span class="keyword">as</span> <span class="variable">$0</span>,<span class="variable">$2</span> <span class="keyword">as</span> <span class="variable">$1</span> from ( </span><br><span class="line">     select T<span class="number">0</span>.<span class="variable">$0</span> <span class="keyword">as</span> <span class="variable">$0</span>, T<span class="number">0</span>.<span class="variable">$1</span> <span class="keyword">as</span> <span class="variable">$1</span>, T1.<span class="variable">$0</span> <span class="keyword">as</span> <span class="variable">$2</span>, T1.<span class="variable">$1</span> <span class="keyword">as</span> <span class="variable">$3</span> </span><br><span class="line">     from (select T<span class="number">0</span>.<span class="variable">$0</span> <span class="keyword">as</span> <span class="variable">$0</span>, T<span class="number">0</span>.<span class="variable">$1</span> <span class="keyword">as</span> <span class="variable">$1</span> from nations) T<span class="number">0</span></span><br><span class="line">     join (select T1.<span class="variable">$0</span> <span class="keyword">as</span> <span class="variable">$2</span>, T1.<span class="variable">$1</span> <span class="keyword">as</span> <span class="variable">$3</span> from regions) T1</span><br><span class="line">     on T<span class="number">0</span>.<span class="variable">$1</span> = T1.<span class="variable">$3</span></span><br><span class="line">   )</span><br><span class="line">⑤ select <span class="variable">$0</span> <span class="keyword">as</span> *, <span class="variable">$1</span> <span class="keyword">as</span> *<span class="number">0</span> from(  </span><br><span class="line">     select <span class="variable">$0</span> <span class="keyword">as</span> <span class="variable">$0</span>,<span class="variable">$2</span> <span class="keyword">as</span> <span class="variable">$1</span> from ( </span><br><span class="line">       select T<span class="number">0</span>.<span class="variable">$0</span> <span class="keyword">as</span> <span class="variable">$0</span>, T<span class="number">0</span>.<span class="variable">$1</span> <span class="keyword">as</span> <span class="variable">$1</span>, T1.<span class="variable">$0</span> <span class="keyword">as</span> <span class="variable">$2</span>, T1.<span class="variable">$1</span> <span class="keyword">as</span> <span class="variable">$3</span> </span><br><span class="line">       from (select T<span class="number">0</span>.<span class="variable">$0</span> <span class="keyword">as</span> <span class="variable">$0</span>, T<span class="number">0</span>.<span class="variable">$1</span> <span class="keyword">as</span> <span class="variable">$1</span> from nations) T<span class="number">0</span></span><br><span class="line">       join (select T1.<span class="variable">$0</span> <span class="keyword">as</span> <span class="variable">$2</span>, T1.<span class="variable">$1</span> <span class="keyword">as</span> <span class="variable">$3</span> from regions) T1</span><br><span class="line">       on T<span class="number">0</span>.<span class="variable">$1</span> = T1.<span class="variable">$3</span></span><br><span class="line">     )</span><br><span class="line">   )</span><br><span class="line">   select *,*<span class="number">0</span> from ...</span><br></pre></td></tr></table></figure>
<p>上面的StarColumn规则有点复杂, 我们看下Join列冲突的规则. 对应上面的③JOIN. 将所有的列都重命名了($0,$1,$2,$3, 然后以$1,$3进行join).  </p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * <span class="number">1.</span>)</span><br><span class="line"> * <span class="built_in">Join</span> might cause naming conflicts from its <span class="built_in">left</span> <span class="keyword">and</span> <span class="built_in">right</span> child.</span><br><span class="line"> * <span class="keyword">In</span> such <span class="keyword">case</span>, we have <span class="keyword">to</span> insert Project <span class="keyword">to</span> rename the conflicting names.</span><br><span class="line"> */</span><br><span class="line">phyRelNode = JoinPrelRenameVisitor.insertRenameProject(phyRelNode);</span><br></pre></td></tr></table></figure>
<p>根据注释中说的join有left或者right child. 注意child这个词的含义. join作为根, 而left和right表分别是根的左右子节点.    </p>
<blockquote>
<p>为了防止名称冲突, 添加project, 这样就和上面我们看到的可视化Plan图是一一对应的了.<br>那么思考下: 这里的join插入的Project是在①和②,还是④??<br>我觉得是在④这里, 因为①和②已经在上面第一个转换规则StarColumnConverter中运用过了.  </p>
</blockquote>
<p>insert操作让传入的phyRelNode节点调用它的accept方法, 并接收JoinPrelRenameVisitor实例对象.  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">JoinPrelRenameVisitor</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">BasePrelVisitor&lt;Prel</span>, <span class="title">Void</span>, <span class="title">RuntimeException&gt;</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span> static <span class="type">JoinPrelRenameVisitor</span> <span class="type">INSTANCE</span> = <span class="keyword">new</span> <span class="type">JoinPrelRenameVisitor</span>();</span><br><span class="line"></span><br><span class="line">  public static <span class="type">Prel</span> insertRenameProject(<span class="type">Prel</span> prel)&#123;</span><br><span class="line">    <span class="keyword">return</span> prel.accept(<span class="type">INSTANCE</span>, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里的Prel通过层层的规则嵌套, 最终返回的还是一个Prel, 也就是说,每次运用一个规则,都要把当前最新值传进来. Prel也实现了DrillRelNode接口.<br>DrillRelNode再结合上Visitor, 有种层层嵌套的感觉.首先注册操作符的规则,从而构成一张图,最后根据DAG图访问每个操作符的时候,再运用上规则. </p>
<p>假设上面JoinPrelRenameVisitor的insertRenameProject的Prel是JoinPrel</p>
<p><img src="http://7xjs7x.com1.z0.glb.clouddn.com/drill15.png" alt=""></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinPrel</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">DrillJoinRelBase</span> <span class="title">implements</span> <span class="title">Prel</span>&#123;</span></span><br><span class="line">  public &lt;<span class="type">T</span>, <span class="type">X</span>, <span class="type">E</span> <span class="keyword">extends</span> <span class="type">Throwable</span>&gt; <span class="type">T</span> accept(<span class="type">PrelVisitor</span>&lt;<span class="type">T</span>, <span class="type">X</span>, <span class="type">E</span>&gt; logicalVisitor, <span class="type">X</span> value) <span class="keyword">throws</span> <span class="type">E</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> logicalVisitor.visitJoin(<span class="keyword">this</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public <span class="type">Iterator</span>&lt;<span class="type">Prel</span>&gt; iterator() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">PrelUtil</span>.iter(getLeft(), getRight());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>accept()的参数logicalVisitor显然就是JoinPrelRenameVisitor了. this是当前对象即JoinPrel.<br>那么就要调用JoinPrelRenameVisitor的visitJoin方法. 你看又回到Visitor来了.  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">JoinPrelRenameVisitor</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">BasePrelVisitor&lt;Prel</span>, <span class="title">Void</span>, <span class="title">RuntimeException&gt;</span>&#123;</span></span><br><span class="line"></span><br><span class="line">  public <span class="type">Prel</span> visitJoin(<span class="type">JoinPrel</span> prel, <span class="type">Void</span> value) <span class="keyword">throws</span> <span class="type">RuntimeException</span> &#123;</span><br><span class="line">    <span class="type">List</span>&lt;<span class="type">RelNode</span>&gt; children = <span class="type">Lists</span>.newArrayList();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">Prel</span> child : prel)&#123;</span><br><span class="line">      child = child.accept(<span class="keyword">this</span>, <span class="literal">null</span>);</span><br><span class="line">      children.add(child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> int leftCount = children.get(<span class="number">0</span>).getRowType().getFieldCount();</span><br><span class="line">    <span class="type">List</span>&lt;<span class="type">RelNode</span>&gt; reNamedChildren = <span class="type">Lists</span>.newArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="type">RelNode</span> left = prel.getJoinInput(<span class="number">0</span>, children.get(<span class="number">0</span>));</span><br><span class="line">    <span class="type">RelNode</span> right = prel.getJoinInput(leftCount, children.get(<span class="number">1</span>));</span><br><span class="line">    reNamedChildren.add(left);</span><br><span class="line">    reNamedChildren.add(right);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">Prel</span>) prel.copy(prel.getTraitSet(), reNamedChildren);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JoinPrel是个迭代器, 因此用for-loop方式可以遍历它的节点: 即参与join的left和right表(实现了iterator方法).<br>JoinPrel的getJoinInput方法参数是offset和RelNode. offset表示join之后列的索引(两张表join后的所有列). </p>
<p>假设我们用两张一样的表进行join,可以看到相同的列, 右边的表会被重命名:  </p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select * from dfs.<span class="code">`/usr/install/apache-drill-1.1.0/sample-data/region.parquet`</span> region1</span><br><span class="line">join dfs.<span class="code">`/usr/install/apache-drill-1.1.0/sample-data/region.parquet`</span> regions</span><br><span class="line"><span class="header">on region1.R_REGIONKEY = regions.R_REGIONKEY;</span><br><span class="line">+--------------+--------------+-----------------------+---------------+--------------+-----------------------+</span></span><br><span class="line"><span class="header">| R_REGIONKEY  |    R_NAME    |       R_COMMENT       | R_REGIONKEY0  |   R_NAME0    |      R_COMMENT0       |</span><br><span class="line">+--------------+--------------+-----------------------+---------------+--------------+-----------------------+</span></span><br><span class="line">| 0            | AFRICA       | lar deposits. blithe  | 0             | AFRICA       | lar deposits. blithe  |</span><br></pre></td></tr></table></figure>
<p>分别调用两次getJoinInput,传入不同的offset和input, 这两个结果一定是不同的.   </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check to make sure that the fields of the inputs are the same as the output field names.  If not, insert a project renaming them.</span></span><br><span class="line">public RelNode getJoinInput(<span class="built_in">int</span> offset, RelNode input) &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; fields = getRowType().getFieldNames();</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; inputFields = input.getRowType().getFieldNames();</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; outputFields = fields.subList(offset, offset + inputFields.size());</span><br><span class="line">  <span class="keyword">if</span> (!outputFields.equals(inputFields)) &#123;</span><br><span class="line">    <span class="comment">// Ensure that input field names are the same as output field names.</span></span><br><span class="line">    <span class="comment">// If there are duplicate field names on left and right, fields will get lost.</span></span><br><span class="line">    <span class="comment">// In such case, we need insert a rename Project on top of the input.</span></span><br><span class="line">    <span class="keyword">return</span> rename(input, input.getRowType().getFieldList(), outputFields);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的处理不知道什么情况下会进入if部分.  假设有两张表都是A,B,C三列.<br>left表不可能有重复的列名, right表相对于left而言,三个列都是重复的. 调用getJoinInput(3, rightNode){}<br>inputFields=[A,B,C], fields=[A,B,C,A,B,C]. outputFields=[A,B,C],不是相等的吗??</p>
</blockquote>
<p>看下相同表的join的可视化树, 对比一下就知道了, 在00-04中加了Project:  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>-<span class="number">00</span>    Screen : rowType = RecordType(ANY *, ANY *<span class="number">0</span>): rowcount = <span class="number">5.0</span>, cumulative cost = &#123;<span class="number">20.5</span> rows, <span class="number">120.5</span> cpu, <span class="number">0.0</span> io, <span class="number">0.0</span> network, <span class="number">88.0</span> memory&#125;, id = <span class="number">1299</span></span><br><span class="line"><span class="number">00</span>-<span class="number">01</span>      ProjectAllowDup(*=[$<span class="number">0</span>], *<span class="number">0</span>=[$<span class="number">1</span>]) : rowType = RecordType(ANY *, ANY *<span class="number">0</span>): rowcount = <span class="number">5.0</span>, cumulative cost = &#123;<span class="number">20.0</span> rows, <span class="number">120.0</span> cpu, <span class="number">0.0</span> io, <span class="number">0.0</span> network, <span class="number">88.0</span> memory&#125;, id = <span class="number">1298</span></span><br><span class="line"><span class="number">00</span>-<span class="number">02</span>        Project(T0¦¦*=[$<span class="number">0</span>], T1¦¦*=[$<span class="number">2</span>]) : rowType = RecordType(ANY T0¦¦*, ANY T1¦¦*): rowcount = <span class="number">5.0</span>, cumulative cost = &#123;<span class="number">20.0</span> rows, <span class="number">120.0</span> cpu, <span class="number">0.0</span> io, <span class="number">0.0</span> network, <span class="number">88.0</span> memory&#125;, id = <span class="number">1297</span></span><br><span class="line"><span class="number">00</span>-<span class="number">03</span>          HashJoin(condition=[=($<span class="number">1</span>, $<span class="number">3</span>)], joinType=[inner]) : rowType = RecordType(ANY T0¦¦*, ANY R_REGIONKEY, ANY T1¦¦*, ANY R_REGIONKEY0): rowcount = <span class="number">5.0</span>, cumulative cost = &#123;<span class="number">20.0</span> rows, <span class="number">120.0</span> cpu, <span class="number">0.0</span> io, <span class="number">0.0</span> network, <span class="number">88.0</span> memory&#125;, id = <span class="number">1296</span></span><br><span class="line"><span class="number">00</span>-<span class="number">04</span>            Project(T1¦¦*=[$<span class="number">0</span>], R_REGIONKEY0=[$<span class="number">1</span>]) : rowType = RecordType(ANY T1¦¦*, ANY R_REGIONKEY0): rowcount = <span class="number">5.0</span>, cumulative cost = &#123;<span class="number">5.0</span> rows, <span class="number">10.0</span> cpu, <span class="number">0.0</span> io, <span class="number">0.0</span> network, <span class="number">0.0</span> memory&#125;, id = <span class="number">1295</span></span><br><span class="line"><span class="number">00</span>-<span class="number">06</span>              Project(T1¦¦*=[$<span class="number">0</span>], R_REGIONKEY=[$<span class="number">1</span>]) : rowType = RecordType(ANY T1¦¦*, ANY R_REGIONKEY): rowcount = <span class="number">5.0</span>, cumulative cost = &#123;<span class="number">5.0</span> rows, <span class="number">10.0</span> cpu, <span class="number">0.0</span> io, <span class="number">0.0</span> network, <span class="number">0.0</span> memory&#125;, id = <span class="number">1294</span></span><br><span class="line"><span class="number">00</span>-<span class="number">08</span>                Scan(groupscan=[ParquetGroupScan [entries=[ReadEntryWithPath [path=file:/usr/install/apache-drill-<span class="number">1.1</span><span class="number">.0</span>/sample-data/region.parquet]], selectionRoot=file:/usr/install/apache-drill-<span class="number">1.1</span><span class="number">.0</span>/sample-data/region.parquet, numFiles=<span class="number">1</span>, columns=[`*`]]]) : rowType = (DrillRecordRow[*, R_REGIONKEY]): rowcount = <span class="number">5.0</span>, cumulative cost = &#123;<span class="number">5.0</span> rows, <span class="number">10.0</span> cpu, <span class="number">0.0</span> io, <span class="number">0.0</span> network, <span class="number">0.0</span> memory&#125;, id = <span class="number">1293</span></span><br><span class="line"><span class="number">00</span>-<span class="number">05</span>            Project(T0¦¦*=[$<span class="number">0</span>], R_REGIONKEY=[$<span class="number">1</span>]) : rowType = RecordType(ANY T0¦¦*, ANY R_REGIONKEY): rowcount = <span class="number">5.0</span>, cumulative cost = &#123;<span class="number">5.0</span> rows, <span class="number">10.0</span> cpu, <span class="number">0.0</span> io, <span class="number">0.0</span> network, <span class="number">0.0</span> memory&#125;, id = <span class="number">1292</span></span><br><span class="line"><span class="number">00</span>-<span class="number">07</span>              Scan(groupscan=[ParquetGroupScan [entries=[ReadEntryWithPath [path=file:/usr/install/apache-drill-<span class="number">1.1</span><span class="number">.0</span>/sample-data/region.parquet]], selectionRoot=file:/usr/install/apache-drill-<span class="number">1.1</span><span class="number">.0</span>/sample-data/region.parquet, numFiles=<span class="number">1</span>, columns=[`*`]]]) : rowType = (DrillRecordRow[*, R_REGIONKEY]): rowcount = <span class="number">5.0</span>, cumulative cost = &#123;<span class="number">5.0</span> rows, <span class="number">10.0</span> cpu, <span class="number">0.0</span> io, <span class="number">0.0</span> network, <span class="number">0.0</span> memory&#125;, id = <span class="number">1291</span></span><br></pre></td></tr></table></figure>
<p><img src="http://7xjs7x.com1.z0.glb.clouddn.com/drill16.png" alt=""></p>

			  
		</div>

		<!-- pagination -->
	  

		
  


	</div>
	<div class="col-md-4">
		
			
				<div id="sidebar">
	 			
	 					
<div class="widget">
  <h4>最新文章</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2015/11/30/2015-11-29-StreamCQL-application/"  > <i class="mdi-editor-insert-drive-file"></i>StreamCQL源码阅读(4) 应用程序执行</a>
      </li>
    
      <li>
        <a href="/2015/11/30/2015-11-27-StreamCQL-operator/"  > <i class="mdi-editor-insert-drive-file"></i>StreamCQL源码阅读(3) 拆分组合算子</a>
      </li>
    
      <li>
        <a href="/2015/11/30/2015-11-26-StreamCQL-schema/"  > <i class="mdi-editor-insert-drive-file"></i>StreamCQL源码阅读(2) 语法和语义解析</a>
      </li>
    
      <li>
        <a href="/2015/11/30/2015-11-24-StreamCQL-task/"  > <i class="mdi-editor-insert-drive-file"></i>StreamCQL源码阅读(1) 提交任务</a>
      </li>
    
      <li>
        <a href="/2015/11/30/2015-11-10-Cassandra-Client/"  > <i class="mdi-editor-insert-drive-file"></i>Cassandra Client查询优化</a>
      </li>
    
  </ul>
</div>


	 				
	 					
<div class="widget">
	<h4>链接</h4>
	<ul class="blogroll list-unstyled">
	
		<li> <a href="http://www.github.com/zqhxuyuan" title="同性交友社区" target="_blank"> <i class="mdi-action-launch"></i> GitHub</a></li>
	
		<li> <a href="http://www.weibo.com/xuyuantree" title="" target="_blank"> <i class="mdi-action-launch"></i> Weibo</a></li>
	
	</ul>
</div>


	 				
	 			</div>
			
		
	</div>

</div>


			<footer>
				

<p>
  由 <a href="https://hexo.io">hexo</a> 强力驱动 | 搭载 <a href="https://github.com/wayou/hexo-theme-material">material</a> 主题
</p>
<p>
  &copy; 2015 <a href="http://github.com/zqhxuyuan"> zqhxuyuan </a>
</p>
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

			</footer>
	  </div>

		<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script>
		<script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>

		<!-- material design -->
		<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script>
		<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>
		<!-- toc -->
		<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script>
		<script src="/libs/tocify/jquery.tocify.custom.js"></script>

		<script src="/js/main.js"></script>

	</body>
</html>
