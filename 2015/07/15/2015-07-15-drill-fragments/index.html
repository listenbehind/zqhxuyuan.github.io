<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Apache Drill源码阅读(5) Fragment | zqhxuyuan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="大数据源码阅读系列之ApacheDrill: 什么是Fragment? 为什么要分成Fragment?">
<meta property="og:type" content="article">
<meta property="og:title" content="Apache Drill源码阅读(5) Fragment">
<meta property="og:url" content="http://github.com/zqhxuyuan/2015/07/15/2015-07-15-drill-fragments/index.html">
<meta property="og:site_name" content="zqhxuyuan">
<meta property="og:description" content="大数据源码阅读系列之ApacheDrill: 什么是Fragment? 为什么要分成Fragment?">
<meta property="og:image" content="http://7xjs7x.com1.z0.glb.clouddn.com/drill-pop.png">
<meta property="og:image" content="http://drill.apache.org/docs/img/execution-tree.PNG">
<meta property="og:image" content="http://drill.apache.org/docs/img/ex-operator.png">
<meta property="og:image" content="http://7xjs7x.com1.z0.glb.clouddn.com/drill24.png">
<meta property="og:image" content="http://7xjs7x.com1.z0.glb.clouddn.com/drill26.png">
<meta property="og:image" content="http://7xjs7x.com1.z0.glb.clouddn.com/drill25.png">
<meta property="og:image" content="http://7xjs7x.com1.z0.glb.clouddn.com/drill27.png">
<meta property="og:updated_time" content="2015-12-02T12:40:23.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Apache Drill源码阅读(5) Fragment">
<meta name="twitter:description" content="大数据源码阅读系列之ApacheDrill: 什么是Fragment? 为什么要分成Fragment?">
  
    <link rel="alternative" href="/atom.xml" title="zqhxuyuan" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars1.githubusercontent.com/u/1088525?v=3&amp;s=180" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">任何忧伤,都抵不过世界的美丽</a></h1>
		</hgroup>

		
				


		
			<div id="switch-btn" class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div id="switch-area" class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives/">归档</a></li>
				        
							<li><a href="/tags/">标签</a></li>
				        
							<li><a href="/about/">关于</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<ul class="social">
							
								<li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/xuyuantree" title="新浪微博"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="http://github.com/zqhxuyuan" title="GitHub"></a></li>
					        
						</ul>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/apex/" style="font-size: 10px;">apex</a> <a href="/tags/cassandra/" style="font-size: 18.57px;">cassandra</a> <a href="/tags/clojure/" style="font-size: 10px;">clojure</a> <a href="/tags/drill/" style="font-size: 17.14px;">drill</a> <a href="/tags/druid/" style="font-size: 14.29px;">druid</a> <a href="/tags/elasticsearch/" style="font-size: 10px;">elasticsearch</a> <a href="/tags/geode/" style="font-size: 10px;">geode</a> <a href="/tags/graph/" style="font-size: 10px;">graph</a> <a href="/tags/hbase/" style="font-size: 15.71px;">hbase</a> <a href="/tags/ignite/" style="font-size: 10px;">ignite</a> <a href="/tags/kafka/" style="font-size: 20px;">kafka</a> <a href="/tags/redis/" style="font-size: 11.43px;">redis</a> <a href="/tags/scala/" style="font-size: 12.86px;">scala</a> <a href="/tags/spark/" style="font-size: 14.29px;">spark</a> <a href="/tags/storm/" style="font-size: 15.71px;">storm</a> <a href="/tags/timeseries/" style="font-size: 12.86px;">timeseries</a> <a href="/tags/work/" style="font-size: 12.86px;">work</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">BIG(DATA)</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">任何忧伤,都抵不过世界的美丽</a></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<a href="/" class="profilepic">
				<img lazy-src="https://avatars1.githubusercontent.com/u/1088525?v=3&amp;s=180" class="js-avatar">
			</a>
			<hgroup>
			  <h1 class="header-author"><a href="/" title="回到主页">任何忧伤,都抵不过世界的美丽</a></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives/">归档</a></li>
		        
					<li><a href="/tags/">标签</a></li>
		        
					<li><a href="/about/">关于</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
						<ul class="social">
							
								<li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/xuyuantree" title="新浪微博"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="http://github.com/zqhxuyuan" title="GitHub"></a></li>
					        
						</ul>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-2015-07-15-drill-fragments" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/15/2015-07-15-drill-fragments/" class="article-date">
  	<time datetime="2015-07-14T16:00:00.000Z" itemprop="datePublished">2015-07-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Apache Drill源码阅读(5) Fragment
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Source/">Source</a>
	</div>


        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/drill/">drill</a></li></ul>
	</div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>大数据源码阅读系列之ApacheDrill: 什么是Fragment? 为什么要分成Fragment?  </p>
<a id="more"></a>
<h2 id="Foreman-runPhysicalPlan运行物理计划">Foreman.runPhysicalPlan运行物理计划</h2><p>在查询一节中说过: <code>有了物理计划,所有的统计信息,最优端点,Foreman中的Parallellizer会将物理计划转换为多个fragments</code><br>将物理计划转换为fragments是在Foreman中, 就是在runPhysicalPlan的第一步getQueryWorkUnit中  </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function">QueryWorkUnit <span class="title">getQueryWorkUnit</span><span class="params">(<span class="keyword">final</span> PhysicalPlan plan)</span> <span class="keyword">throws</span> ExecutionSetupException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> PhysicalOperator rootOperator = plan.getSortedOperators(<span class="keyword">false</span>).iterator().next();   <span class="comment">// 物理计划的根节点物理操作符为Screen</span></span><br><span class="line">  <span class="keyword">final</span> Fragment rootFragment = rootOperator.accept(MakeFragmentsVisitor.INSTANCE, <span class="keyword">null</span>);   <span class="comment">// ①递归调用树入口,从上到下调用每个操作符的accept方法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> SimpleParallelizer parallelizer = <span class="keyword">new</span> SimpleParallelizer(queryContext);   <span class="comment">// 并行, 用来设置fragments的并行度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> QueryWorkUnit queryWorkUnit = parallelizer.getFragments(</span><br><span class="line">      queryContext.getOptions().getOptionList(), queryContext.getCurrentEndpoint(),</span><br><span class="line">      queryId, queryContext.getActiveEndpoints(), drillbitContext.getPlanReader(), rootFragment,</span><br><span class="line">      initiatingClient.getSession(), queryContext.getQueryContextInfo());</span><br><span class="line">  <span class="keyword">return</span> queryWorkUnit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在debug一节,我们知道DrillRel drel, Prel prel, PhysicalOperator pop, PhysicalPlan plan各个变量的值.<br>上面通过PhysicalPlan获得的rootOperator就是PhysicalOperator pop根节点, 即<code>rootOperator=Screen</code>.  </p>
<p><img src="http://7xjs7x.com1.z0.glb.clouddn.com/drill-pop.png" alt=""></p>
<p>rootOperator.accept后返回的是rootFragment.  然后通过root又开始递归遍历了(跟debug一节rootLOP.accept一样).<br>下面是MakeFragmentsVisitor访问器当访问到的是一个操作符时, 首先将当前操作符加入到Fragment中, 然后遍历其孩子节点.  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Fragment <span class="title">visitOp</span>(<span class="params">PhysicalOperator op, Fragment <span class="keyword">value</span></span>)  throws ForemanSetupException</span>&#123;</span><br><span class="line">  <span class="keyword">value</span> = ensureBuilder(<span class="keyword">value</span>);</span><br><span class="line">  <span class="keyword">value</span>.addOperator(op);</span><br><span class="line">  <span class="keyword">for</span> (PhysicalOperator child : op) &#123;</span><br><span class="line">    child.accept(<span class="keyword">this</span>, <span class="keyword">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是Screen-&gt;..-&gt;Scan的递归调用示例树:  </p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">rootOperator</span><span class="string">.</span><span class="comment">accept(v</span><span class="string">,</span><span class="comment">null)</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">Screen</span><span class="string">.</span><span class="comment">accept(visitor</span><span class="string">,</span> <span class="comment">null)</span></span><br><span class="line">                          <span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="comment">MakeFragmentsVisitor</span><span class="string">.</span><span class="comment">visitOp</span></span><br><span class="line">                                        <span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="comment">value=new</span> <span class="comment">Fragment</span> </span><br><span class="line">                                        <span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="comment">value</span><span class="string">.</span><span class="comment">addOperator(Screen)</span></span><br><span class="line">                                        <span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="comment">for</span> <span class="comment">child</span> <span class="comment">:</span> <span class="title">[</span><span class="comment">EasyGroupScan</span><span class="title">]</span><span class="literal">-</span><span class="literal">-</span><span class="comment">child</span><span class="string">.</span><span class="comment">accept(visitor</span><span class="string">,</span> <span class="comment">value)</span>    <span class="comment">我们省略了中间的一些节点</span><span class="string">,</span><span class="comment">假设Screen的下一个节点是Scan</span></span><br><span class="line">                                                     <span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="comment">EasyGroupScan</span><span class="string">.</span><span class="comment">accept(visitor</span><span class="string">,</span> <span class="comment">value)</span></span><br><span class="line">                                                                    <span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="comment">MakeFragmentsVisitor</span><span class="string">.</span><span class="comment">visitOp</span></span><br><span class="line">                                                                    <span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="comment">value</span><span class="string">.</span><span class="comment">addOperator(EasyGroupScan)</span></span><br><span class="line">                                                                    <span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="comment">EasyGroupScan</span> <span class="comment">has</span> <span class="comment">no</span> <span class="comment">child</span></span><br><span class="line">                                                                    <span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="comment">return</span> <span class="comment">value</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>递归调用树有点类似于设计模式中的访问者模式(Visitor Pattern).  </p>
</blockquote>
<p>返回值<code>Fragment rootFragment = rootOperator.accept(MakeFragmentsVisitor.INSTANCE, null);</code><br>因为参数是null, 所以第一次调用rootOperator.accept的时候就创建了新的Fragment. 接下来child.accept,<br>因为把value : Fragment传入, 所以不会再构造Fragment了(除非出现Exchange的时候才会new一个新的Fragment).<br>注意在每次递归调用child.accept之前, 把当前的物理操作符加入到Fragment中.<br>也就是说物理计划组成的DAG图的每个物理操作符都会加入到Fragment中, 这个Fragment并不代表DAG图中的某个节点(比如根节点), 而是包含了所有的操作符.<br>这和前面的DrillRel, Prel, PhysicalOperator, PhysicalPlan不一样:它们的值是DAG图的第一个节点,然后通过input或者child嵌套包含其他节点.  </p>
<p>当然Fragment中要有根物理操作符, 这样把根拎出来, 其他所有的操作符也都能找到了.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fragment</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Fragment</span>.<span class="title">ExchangeFragmentPair</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> PhysicalOperator root;</span><br><span class="line">  <span class="keyword">private</span> ExchangeFragmentPair sendingExchange;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ExchangeFragmentPair&gt; receivingExchangePairs = Lists.newLinkedList();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the given operator as root operator of this fragment. If root operator is already set, then this method call is a no-op.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOperator</span><span class="params">(PhysicalOperator o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      root = o;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSendExchange</span><span class="params">(Exchange e, Fragment sendingToFragment)</span> <span class="keyword">throws</span> ForemanSetupException</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (sendingExchange != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ForemanSetupException(<span class="string">"Fragment was trying to add a second SendExchange.  "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      addOperator(e);</span><br><span class="line">      sendingExchange = <span class="keyword">new</span> ExchangeFragmentPair(e, sendingToFragment);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addReceiveExchange</span><span class="params">(Exchange e, Fragment fragment)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.receivingExchangePairs.add(<span class="keyword">new</span> ExchangeFragmentPair(e, fragment));</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MakeFragmentsVisitor如果访问到的是一个Exchange操作符, Exchange会和Fragment组成一个ExchangeFragmentPair.  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Fragment <span class="title">visitExchange</span>(<span class="params">Exchange exchange, Fragment <span class="keyword">value</span></span>) throws ForemanSetupException </span>&#123;</span><br><span class="line">  Fragment next = getNextBuilder();           <span class="comment">// 总是会新建一个新的Fragment:next</span></span><br><span class="line">  <span class="keyword">value</span>.addReceiveExchange(exchange, next);   <span class="comment">// 将Exchange操作符和新的Fragment组成一个ExchangeFragmentPair, 添加到原来Fragment的list中</span></span><br><span class="line">  next.addSendExchange(exchange, <span class="keyword">value</span>);      <span class="comment">// Exchange操作符和原来的Fragment也会组成一个ExchangeFragmentPair,不过用于发送</span></span><br><span class="line">  exchange.getChild().accept(<span class="keyword">this</span>, next);     <span class="comment">// Exchange下面的孩子节点, 用的Fragment是新的那一个</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">value</span>;                               <span class="comment">// 但是我们最后返回的, 仍然是第一次新建的那一个Fragment</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用这个方法时, value一定不为空: The simple fragmenter was called without a FragmentBuilder value.<br>This will only happen if the initial call to SimpleFragmenter  is by a Exchange node.<br>This should never happen since an Exchange node should never be the root node of a plan<br>一个Exchange节点永远不能是一个计划的根节点.  Exchange前是一个Major Fragment, Exchange后也是一个Major Fragment.  </p>
<blockquote>
<p>至于为什么先是Receiver,然后是Sender, 我们先看下官网中的概念,以及举个带有Exchange的例子: </p>
</blockquote>
<h2 id="fragments_theory">fragments theory</h2><blockquote>
<p><a href="http://drill.apache.org/docs/drill-query-execution/" target="_blank" rel="external">http://drill.apache.org/docs/drill-query-execution/</a><br>A parallelizer in the Foreman transforms the physical plan into multiple phases, called major and minor fragments.<br>These fragments create a multi-level execution tree that rewrites the query and executes it in<br>parallel against the configured data sources, sending the results back to the client or application.</p>
<p>并行化会将物理计划分成多个阶段. 什么时候需要并行? 任务是可以分解的时候, 任务之间没有关联, 比如Hadoop的MapReduce就是可并行化的.<br>这些阶段叫做major或者minor fragmens. 它们组成了一个多层的执行树, 重写查询, 并且能够并行地在数据源上执行.  </p>
<p>以传统DAG图的方式, 只有前面的节点处理完后,后面的节点才会继续运行. 而用并行化的方式,每个节点运行完一部分数据,后面的节点就可以接着这些数据进行计算.</p>
</blockquote>
<p><img src="http://drill.apache.org/docs/img/execution-tree.PNG" alt=""></p>
<h2 id="Major_Fragments">Major Fragments</h2><blockquote>
<p>Drill separates major fragments by an exchange operator. An exchange is a change in data location and/or parallelization of the physical plan.<br>An exchange is composed of a sender and a receiver to allow data to move between nodes  </p>
<p>Drill用交换操作符来分隔major fragments. 一个交换操作符是数据位置的交换, 或者物理计划并行度的变更.<br>一个交换操作符由一个发送器和一个接收器组成, 以运行数据在不同节点之间进行移动. </p>
<p>Major fragments do not actually perform any query tasks. Each major fragment is divided into one or multiple minor fragments<br>that actually execute the operations required to complete the query and return results back to the client. </p>
<p>Major Fragments不执行任何的查询任务, 每个major fragments会分成一个或多个minor fragments.<br>Minor Fragments会执行完成这个查询需要的操作, 并且返回结果给客户端.  </p>
</blockquote>
<p><img src="http://drill.apache.org/docs/img/ex-operator.png" alt=""></p>
<p>那么什么时候会产生Major Fragments: 读取的是HDFS上的文件时(count(*)无条件查询即使是hdfs文件也没有exchange).  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- <span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> hdfs.<span class="string">`/user/hive/warehouse/test.db/koudai`</span></span><br><span class="line">+ <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> hdfs.<span class="string">`/user/hive/warehouse/test.db/koudai`</span> <span class="keyword">where</span> sequence_id <span class="keyword">like</span> <span class="string">'%12%'</span></span><br><span class="line">+ <span class="keyword">select</span> <span class="keyword">t</span>.event_result_map.<span class="keyword">map</span> <span class="keyword">from</span> hdfs.<span class="string">`/user/hive/warehouse/test.db/koudai`</span> <span class="keyword">t</span> <span class="keyword">where</span> <span class="keyword">t</span>.sequence_id=<span class="string">'1433300095954-25887486'</span></span><br><span class="line">+ <span class="keyword">select</span> <span class="keyword">t</span>.sequence_id <span class="keyword">from</span> hdfs.<span class="string">`/user/hive/warehouse/test.db/koudai`</span> <span class="keyword">t</span> <span class="keyword">limit</span> <span class="number">1</span></span><br><span class="line">+ <span class="keyword">select</span> * <span class="keyword">from</span> hdfs.<span class="string">`/user/hive/warehouse/test.db/koudai`</span> <span class="keyword">limit</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">- <span class="keyword">select</span> * <span class="keyword">from</span> cp.<span class="string">`employee.json`</span> <span class="keyword">limit</span> <span class="number">1</span></span><br><span class="line">- <span class="keyword">select</span> * <span class="keyword">from</span> dfs.<span class="string">`/Users/zhengqh/data/hive_alltypes.parquet`</span> <span class="keyword">limit</span> <span class="number">1</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么无条件的count(<em>)查询没有exchange. 观察Operator,发现count查询底层的scan是DIRECT_SUB_SCAN,<br>而parquet的其他查询(带条件的count,where,limit,</em>)用的是PARQUET_ROW_GROUP_SCAN. 后面的cp和本地查询则没有Exchange.    </p>
</blockquote>
<p>下图中白色的UnionExchange分隔了两个Major Fragments. totalFragments的个数指的是所有的minor framgnet.<br>对比DAG图和Operator Profiles. 可以看到Exchange对应的Operator是Receiver和Sender.  </p>
<p><img src="http://7xjs7x.com1.z0.glb.clouddn.com/drill24.png" alt=""> <img src="http://7xjs7x.com1.z0.glb.clouddn.com/drill26.png" alt=""></p>
<blockquote>
<p>注意左侧的UnionExchange在右侧中被分成了Receiver和Sender.  </p>
</blockquote>
<p>第一个Major framgnet在UnionExchange的上方, 即Screen, 只有一个mior Fragment.<br>第二个Major framgnet包括了多个操作符, 有2个minor Fragments. </p>
<p><img src="http://7xjs7x.com1.z0.glb.clouddn.com/drill25.png" alt=""></p>
<h2 id="Receiver+Sender">Receiver+Sender</h2><p>以上图中的Screen-&gt;UnionExchange-&gt;Project-&gt;…-&gt;Scan的顺序分析下UnionExchange:  </p>
<p>在访问根操作符visitOp(Screen,null)时, MakeFragmentsVisitor会新建一个Fragment, 设置Fragment的root=Screen.<br>接着因为Screen的Child是UninonExchange,调用的是MakeFragmentsVisitor的visitExchange(UnionExchange,Fragment value).<br>第二个参数Fragment value是访问Screen时创建的第一个Fragment, 第一个Fragment value一定不为空, 因为不允许根节点是Exchange.  </p>
<p>因为Exchange是用来分隔Major Fragment的, 所以在Exchange之前和之后都要有一个Major Fragment,之前就是第一个Fragment了.<br>重点看下visitExchange的下面的逻辑, 理清到底第一个Fragment value和下一个Fragment next分别添加的是什么组件.  </p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value.addReceiveExchange(exchange, <span class="keyword">next</span>);   // <span class="keyword">first</span> <span class="built_in">add</span> Receiver from <span class="keyword">next</span></span><br><span class="line"><span class="keyword">next</span>.addSendExchange(exchange, value);      // <span class="keyword">next</span> <span class="built_in">add</span> Sender <span class="keyword">to</span> <span class="keyword">first</span></span><br></pre></td></tr></table></figure>
<p>注意我们的DAG图从上到下,第一个节点是Screen,最下面的节点是Scan, 所以上面的是作为接收数据的一方,下面的是发送数据的一方.<br>而first Fragment即上面的value, 是在上方的,那么就是作为接收方Receiver的.<br>而且最后返回给客户端的也是上层的,客户端只需要知道和Screen相关的那个Fragment,即返回值是value.   </p>
<p>第一个Fragment value添加一个Receive Exchange, 只是把新建的ExchangeFragmentPair加入到value的List<exchangefragmentpair> receivingExchangePairs中.<br>而第二个Fragment next我们已经知道了在visitExchange时创建了一个新的Fragment. 对于每一个全新的Fragment, 都要设置root节点操作符.    </exchangefragmentpair></p>
<p>实际上观察前面的DAG图和Operator Profiles,你会发现UnionExchange的UNORDERED_RECEIVER的编号是00-xx-01,因此是属于第一个Fragment的.<br>而SINGLE_SENDER的编号是01-xx-00, 则是属于第二个Fragment. 因此第二个Fragment的root就是SINGLE_SENDER. </p>
<p>上面两个value和next互相添加对方, 实际上是为了在上下文中都能找到对方. 否则如果只是value添加了next. 则在next时就无法找到value的.  </p>
<table>
<thead>
<tr>
<th>Fragment</th>
<th>root</th>
<th>sendingExchange</th>
<th>receivingExchangePairs</th>
<th>Explain</th>
<th>Role</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>Screen</td>
<td>×</td>
<td>ExchangeFragmentPair(e,next)</td>
<td>value的接收者是next</td>
<td>Reciever</td>
</tr>
<tr>
<td>next</td>
<td>SINGLE_SENDER</td>
<td>ExchangeFragmentPair(e,value)</td>
<td>×</td>
<td>next要发送给value</td>
<td>Sender</td>
</tr>
</tbody>
</table>
<p>看看UnionExchange的几个相关方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionExchange</span> <span class="keyword">extends</span> <span class="title">AbstractExchange</span></span>&#123;</span><br><span class="line">  <span class="comment">// Ephemeral info for generating execution fragments. 这几个变量是AbstractExchange中的,为了阅读的方便放在这里</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> senderMajorFragmentId;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> receiverMajorFragmentId;</span><br><span class="line">  <span class="keyword">protected</span> List&lt;DrillbitEndpoint&gt; senderLocations;</span><br><span class="line">  <span class="keyword">protected</span> List&lt;DrillbitEndpoint&gt; receiverLocations;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setupSenders</span><span class="params">(List&lt;DrillbitEndpoint&gt; senderLocations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.senderLocations = senderLocations;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupReceivers</span><span class="params">(List&lt;DrillbitEndpoint&gt; receiverLocations)</span> <span class="keyword">throws</span> PhysicalOperatorSetupException </span>&#123;</span><br><span class="line">    Preconditions.checkArgument(receiverLocations.size() == <span class="number">1</span>, <span class="string">"Union Exchange only supports a single receiver endpoint."</span>);</span><br><span class="line">    <span class="keyword">super</span>.setupReceivers(receiverLocations);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Sender <span class="title">getSender</span><span class="params">(<span class="keyword">int</span> minorFragmentId, PhysicalOperator child)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SingleSender(receiverMajorFragmentId, child, receiverLocations.get(<span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Receiver <span class="title">getReceiver</span><span class="params">(<span class="keyword">int</span> minorFragmentId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnorderedReceiver(senderMajorFragmentId, PhysicalOperatorUtil.getIndexOrderedEndpoints(senderLocations), <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面getSender和getReceiver的第一个参数是minorFragmentId. new一个Sender或者Receiver都要知道对方的MajorFragmentId.<br>比如SingleSender要知道Receiver的MajorFragmentId,以及接收者的一个Location. UnorderReceiver要知道Sender的MajorId,以及所有发送者的Locations.     </p>
<p>SingleSender: <code>Sender that pushes all data to a single destination node.</code> 发送者会发送所有的数据到一个目标节点,那么当然要指定这个目标节点了.<br>这个目标节点应该是跟上表中的sendingExchange变量相关的, 可以看到这一行的root=SINGLE_SENDER. 当然目标节点指的应该是Drillbit级别,而不是Operator了.  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SingleSender</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractSender</span> &#123;</span></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Create a SingleSender which sends data to fragment identified by given MajorFragmentId and MinorFragmentId, and running at given endpoint</span><br><span class="line">   *</span><br><span class="line">   * @param oppositeMajorFragmentId MajorFragmentId of the receiver fragment.</span><br><span class="line">   * @param oppositeMinorFragmentId MinorFragmentId of the receiver fragment.</span><br><span class="line">   * @param child Child operator</span><br><span class="line">   * @param destination Drillbit endpoint where the receiver fragment is running.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="annotation">@JsonCreator</span></span><br><span class="line">  public <span class="type">SingleSender</span>(<span class="annotation">@JsonProperty</span>(<span class="string">"receiver-major-fragment"</span>) int oppositeMajorFragmentId,</span><br><span class="line">                      <span class="annotation">@JsonProperty</span>(<span class="string">"receiver-minor-fragment"</span>) int oppositeMinorFragmentId,</span><br><span class="line">                      <span class="annotation">@JsonProperty</span>(<span class="string">"child"</span>) <span class="type">PhysicalOperator</span> child,</span><br><span class="line">                      <span class="annotation">@JsonProperty</span>(<span class="string">"destination"</span>) <span class="type">DrillbitEndpoint</span> destination) &#123;</span><br><span class="line">    <span class="keyword">super</span>(oppositeMajorFragmentId, child,</span><br><span class="line">        <span class="type">Collections</span>.singletonList(<span class="keyword">new</span> <span class="type">MinorFragmentEndpoint</span>(oppositeMinorFragmentId, destination)));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>MinorFragmentEndpoint represents fragment&#39;s MinorFragmentId and Drillbit endpoint to which the fragment is assigned for execution.</code><br>DrillbitEndpoint是运行’Drillbit’服务的节点(集群的计算节点). MinorFragmentEndpoint是fragment要执行在哪个Drillbit节点,更细粒度(Container?).  </p>
<p>对于Reciever而言, 它可以有多个Sender. </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UnorderedReceiver</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractReceiver</span>&#123;</span></span><br><span class="line">  <span class="annotation">@JsonCreator</span></span><br><span class="line">  public <span class="type">UnorderedReceiver</span>(<span class="annotation">@JsonProperty</span>(<span class="string">"sender-major-fragment"</span>) int oppositeMajorFragmentId,</span><br><span class="line">                           <span class="annotation">@JsonProperty</span>(<span class="string">"senders"</span>) <span class="type">List</span>&lt;<span class="type">MinorFragmentEndpoint</span>&gt; senders,</span><br><span class="line">                           <span class="annotation">@JsonProperty</span>(<span class="string">"spooling"</span>) boolean spooling) &#123;</span><br><span class="line">    <span class="keyword">super</span>(oppositeMajorFragmentId, senders, spooling);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>下面解释下FragmentLeaf这个接口下都有哪些实现类. </p>
<p><img src="http://7xjs7x.com1.z0.glb.clouddn.com/drill27.png" alt=""></p>
<p>FragmentLeaf是一个Fragment的叶子节点, Fragment和DAG图的叶子节点是有点差别呢的. 因为一个DAG图会包括多个Fragment.<br>1.接收者是一个Fragment的叶子, 因为Exchange会分隔Fragment. Fragment的上方是接收者,是上面一个Fragment的叶子节点.<br>2.整个DAG图的叶子节点通常是Scan,是组成DAG最下面的那个Fragment的叶子节点.   </p>
<p>Fragment的Root是一个Fragment的根节点<br>1.发送者是一个Fragment的根节点, 即Exchange分隔的下面一个Fragment的根节点,而Fragment下发是一个Sender.<br>2.整个DAG图的根节点通常是Screen.  </p>
<h2 id="QueryWorkUnit">QueryWorkUnit</h2><p>在运行物理计划的第一句是根据物理计划得到QueryWorkUnit:    </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> QueryWorkUnit work = getQueryWorkUnit(plan);</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;PlanFragment&gt; planFragments = work.getFragments();</span><br><span class="line"><span class="keyword">final</span> PlanFragment rootPlanFragment = work.getRootFragment();</span><br></pre></td></tr></table></figure>
<p>查询的工作单元包含了三个组件, 对于本地而言的根Fragment和根操作符.  这里的本地指的是Foreman.  </p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryWorkUnit</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PlanFragment rootFragment; // <span class="keyword">for</span> <span class="keyword">local</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FragmentRoot rootOperator; // <span class="keyword">for</span> <span class="keyword">local</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PlanFragment&gt; fragments;  // Major+Minor Fragments</span><br></pre></td></tr></table></figure>
<p>而PlanFragment既是Plan又是Fragment.  前面我们知道Fragment由Exchange分成了多个Major Fragment.<br>在遍历物理操作符时, 会将物理操作符加入到对应的Fragment中.  </p>
<h3 id="Protobuf">Protobuf</h3><p>必须上Protobuf这道菜了. 对于理解不同组件之间的关系是有作用的.  其实前面RPC部分也是用到了protobuf.<br>PlanFragment的protobuf定义在BitControl.proto中. FragmentHandle在ExecutionProtos.proto中  </p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">PlanFragment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> FragmentHandle handle = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> network_cost = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> cpu_cost = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> disk_cost = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> memory_cost = <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> fragment_json = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> leaf_fragment = <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">optional</span> DrillbitEndpoint assignment = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">optional</span> DrillbitEndpoint foreman = <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">int64</span> mem_initial = <span class="number">12</span> [default = <span class="number">20000000</span>]; <span class="comment">// 20 megs</span></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">int64</span> mem_max = <span class="number">13</span> [default = <span class="number">2000000000</span>]; <span class="comment">// 20 gigs</span></span><br><span class="line">  <span class="keyword">optional</span> exec.shared.UserCredentials credentials = <span class="number">14</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> options_json = <span class="number">15</span>;</span><br><span class="line">  <span class="keyword">optional</span> QueryContextInformation context = <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">repeated</span> Collector collector = <span class="number">17</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">FragmentHandle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">optional</span> exec.shared.QueryId query_id = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">optional</span> <span class="built_in">int32</span> major_fragment_id = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">optional</span> <span class="built_in">int32</span> minor_fragment_id = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在日志一节, 其中Root Fragment(rootFragment对象)打印的信息如下, 可以看到正好对应了上面的PlanFragment的协议格式:  </p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">handle &#123;				→ FragmentHandle</span><br><span class="line">  query_id &#123;</span><br><span class="line">    part1: <span class="number">3053657859282349058</span></span><br><span class="line">    part2: -<span class="number">8863752500417580646</span></span><br><span class="line">  &#125;</span><br><span class="line">  major_fragment_id: <span class="number">0</span></span><br><span class="line">  minor_fragment_id: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">fragment_json: <span class="string">"&#123;		→ fragment_json</span><br><span class="line">  ...</span><br><span class="line">&#125;"</span></span><br><span class="line">leaf_fragment: <span class="literal">true</span></span><br><span class="line">assignment &#123;			→ DrillbitEndpoint</span><br><span class="line">  address: <span class="string">"localhost"</span></span><br><span class="line">  user_port: <span class="number">31010</span></span><br><span class="line">  control_port: <span class="number">31011</span></span><br><span class="line">  data_port: <span class="number">31012</span></span><br><span class="line">&#125;</span><br><span class="line">foreman &#123;				→ DrillbitEndpoint</span><br><span class="line">  address: <span class="string">"localhost"</span></span><br><span class="line">  user_port: <span class="number">31010</span></span><br><span class="line">  control_port: <span class="number">31011</span></span><br><span class="line">  data_port: <span class="number">31012</span></span><br><span class="line">&#125;</span><br><span class="line">context &#123;</span><br><span class="line">  query_start_time: <span class="number">1436498522273</span></span><br><span class="line">  time_zone: <span class="number">299</span></span><br><span class="line">  default_schema_name: <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="QueryContext_&amp;_DrillbitContext"><strong>QueryContext &amp; DrillbitContext</strong></h3><p>计算fragments要根据查询的上下文QueryContext,以及DrillbitContext.<br>queryContext.getCurrentEndpoint()表示Foreman节点, queryContext.getActiveEndpoints()表示参与计算的其他节点.<br>我们重点看下获取活动的Endpoints是怎么做得, 因为Drill是分布式的计算引擎,添加计算节点能够让计算能力提高.<br>那么它是怎么实现的, 通过ZK的Watcher机制, 如果有节点增加进来,获取可用的计算节点时就是动态实时的.   </p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">queryContext.getActiveEndpoints()</span><br><span class="line">            <span class="string">|</span></span><br><span class="line">            <span class="string">|--&gt;drillbitContext.getBits()</span></span><br><span class="line">                      <span class="string">|     </span></span><br><span class="line">                      <span class="string">|--&gt;ClusterCoordinator.getAvailableEndpoints()</span></span><br><span class="line">                                 <span class="string">|</span></span><br><span class="line">                                 <span class="string">|&lt;--ZKClusterCoordinator.endpoints</span></span><br><span class="line">                                               <span class="string">|</span></span><br><span class="line">                                               <span class="string">|&lt;--updateEndpoints()</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们知道了通过ZK实时获取动态的计算节点, 但是任务是怎么分配到计算节点上的. 我们能不能自定义转发规则??  </p>
</blockquote>
<h3 id="SimpleParallelizer">SimpleParallelizer</h3><p>由SimpleParallelizer获得Fragments, 参数activeEndpoints就是上面从上下文中得到的集群中可用的Drillbit计算节点.<br>rootFragment是rootOperator返回的Fragment, 物理计划的rootOperator一般是Screen. 这里的Fragment指的是由Exchange分割的Major Fragment.  </p>
<p>该方法根据提供的Fragment树生成分配好的Fragments集合, 就是PlanFragment Protobuf对象集合, 会被分配到单独的节点.<br>返回的Fragments(注意是复数形式), 则是Major+Minor级别的Fragment了.  而Minor Fragments可以有多个, 是可以并行处理的.  </p>
<blockquote>
<p>什么是Fragment树?  就是文档中提到的将物理计划转成多个Fragments,这些Fragments组成了一棵树.  </p>
</blockquote>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">final</span> QueryWorkUnit queryWorkUnit = parallelizer.getFragments(</span><br><span class="line">      queryContext.getOptions().getOptionList(), queryContext.getCurrentEndpoint(),</span><br><span class="line">      queryId, queryContext.getActiveEndpoints(), drillbitContext.getPlanReader(), rootFragment,</span><br><span class="line">      initiatingClient.getSession(), queryContext.getQueryContextInfo());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Generate a set of assigned fragments based on the provided fragment tree. Do not allow parallelization stages to go beyond the global max width.</span><br><span class="line"> * <span class="doctag">@param</span> foremanNode       The driving/foreman node for this query.  (this node) 本次查询的驱动节点/Foreman节点.</span><br><span class="line"> * <span class="doctag">@param</span> activeEndpoints   The list of endpoints to consider for inclusion in planning this query. 要计划本次查询, 需要考虑包括在内的计算节点</span><br><span class="line"> * <span class="doctag">@param</span> reader                  Tool used to read JSON plans 读取JSON格式的物理计划</span><br><span class="line"> * <span class="doctag">@param</span> rootFragment      The root node of the PhysicalPlan that we will be parallelizing. 物理计划的根节点(对应的Fragment), 会并行处理. </span><br><span class="line"> * <span class="doctag">@return</span> The list of generated PlanFragment protobuf objects to be assigned out to the individual nodes.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">QueryWorkUnit <span class="title">getFragments</span><span class="params">(OptionList options, DrillbitEndpoint foremanNode, QueryId queryId, Collection&lt;DrillbitEndpoint&gt; activeEndpoints, </span><br><span class="line">    PhysicalPlanReader reader, Fragment rootFragment, UserSession session, QueryContextInformation queryContextInfo)</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> PlanningSet planningSet = <span class="keyword">new</span> PlanningSet();</span><br><span class="line">  initFragmentWrappers(rootFragment, planningSet);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Set&lt;Wrapper&gt; leafFragments = constructFragmentDependencyGraph(planningSet);</span><br><span class="line">  <span class="comment">// Start parallelizing from leaf fragments</span></span><br><span class="line">  <span class="keyword">for</span> (Wrapper wrapper : leafFragments) &#123;</span><br><span class="line">    parallelizeFragment(wrapper, planningSet, activeEndpoints);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">return</span> <span class="title">generateWorkUnit</span><span class="params">(options, foremanNode, queryId, reader, rootFragment, planningSet, session, queryContextInfo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道rootFragment只是代表了DAG图最顶上的那个Major Fragment, 在下面的迭代中,要给DAG图中的每个Major Fragment都添加到planningSet中.  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For every fragment, create a Wrapper in PlanningSet.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initFragmentWrappers</span>(<span class="params">Fragment rootFragment, PlanningSet planningSet</span>) </span>&#123;</span><br><span class="line">  planningSet.<span class="keyword">get</span>(rootFragment);</span><br><span class="line">  <span class="keyword">for</span>(ExchangeFragmentPair fragmentPair : rootFragment) &#123;</span><br><span class="line">    initFragmentWrappers(fragmentPair.getNode(), planningSet);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们再给出Fragment的迭代方法iterator.  for循环迭代的是receivingExchangePairs.<br>前面分析过上一个Fragment作为接收者接收下一个Fragment发送的数据: <code>value.addReceiveExchange(exchange, next);</code><br>那么ExchangeFragmentPair的Node就是next, 即下一个Major Fragment, 然后继续递归下去.  </p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">Fragment</span> implements <span class="type">Iterable</span>&lt;<span class="type">Fragment</span>.<span class="type">ExchangeFragmentPair</span>&gt; &#123;</span><br><span class="line">  private final <span class="type">List</span>&lt;<span class="type">ExchangeFragmentPair</span>&gt; receivingExchangePairs = <span class="type">Lists</span>.newLinkedList();</span><br><span class="line"></span><br><span class="line">  public <span class="type">void</span> addReceiveExchange(<span class="type">Exchange</span> e, <span class="type">Fragment</span> fragment) &#123;</span><br><span class="line">    this.receivingExchangePairs.add(new <span class="type">ExchangeFragmentPair</span>(e, fragment));</span><br><span class="line">  &#125;</span><br><span class="line">  public <span class="type">Iterator</span>&lt;<span class="type">ExchangeFragmentPair</span>&gt; <span class="keyword">iterator</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> this.receivingExchangePairs.<span class="keyword">iterator</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="PlanningSet+Wrapper">PlanningSet+Wrapper</h3><p>既然用到了ReceiveExchange, 下面马上就用到了SendingExchange.  添加是在: <code>next.addSendExchange(exchange, value);</code><br>下面用的不是ExchangeFragmentPair的Fragment了, 而是Fragment的Exchange. 这里要做到的是设置MajorFragmentId.<br>因为由Exchange分割的Major Fragment, 它们的ID分别是00,01,02等等.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlanningSet</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Wrapper</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Fragment, Wrapper&gt; fragmentMap = Maps.newHashMap();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> majorFragmentIdIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Wrapper <span class="title">get</span><span class="params">(Fragment node)</span> </span>&#123;</span><br><span class="line">    Wrapper wrapper = fragmentMap.get(node);</span><br><span class="line">    <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> majorFragmentId = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// If there is a sending exchange, we need to number other than zero.</span></span><br><span class="line">      <span class="keyword">if</span> (node.getSendingExchange() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// assign the upper 16 bits as the major fragment id.</span></span><br><span class="line">        majorFragmentId = node.getSendingExchange().getChild().getOperatorId() &gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="comment">// if they are not assigned, that means we mostly likely have an externally generated plan.  in this case, come up with a major fragmentid.</span></span><br><span class="line">        <span class="keyword">if</span> (majorFragmentId == <span class="number">0</span>)   majorFragmentId = majorFragmentIdIndex;</span><br><span class="line">      &#125;</span><br><span class="line">      wrapper = <span class="keyword">new</span> Wrapper(node, majorFragmentId);  <span class="comment">// Wrapper由Fragment和major编号组成</span></span><br><span class="line">      fragmentMap.put(node, wrapper);</span><br><span class="line">      majorFragmentIdIndex++;  <span class="comment">// 只有调用Major Fragment时, 每遇到新的Major, 索引编号+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrapper;  <span class="comment">// planningSet.get并没有用返回值做什么事情. 其实主要是放到Map中, 由迭代器访问所有的Wrapper.  </span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Iterator&lt;Wrapper&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.fragmentMap.values().iterator();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Wrapper: <code>A wrapping class that allows us to add additional information to each fragment node for planning purposes</code><br>它的构造函数创建对象是由PlanningSet指定MajorFragment和MajorFragmentId. 它的其余属性需要在下面中设置进来.  </p>
<p>先来看下Exchange的并行依赖:  发送者和接收者是否相互依赖.  </p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Exchanges are <span class="keyword">fragment</span> boundaries <span class="keyword">in</span> physical operator tree. It is divided into two parts. First part is Sender</span><br><span class="line"> * which becomes part of the sending <span class="keyword">fragment</span>. Second part is Receiver which becomes part of the <span class="keyword">fragment</span> that receives the data.</span><br><span class="line"> * Exchange是物理操作符树的Fragment边界. 第一部分Sender,它是发送者Fragment的一部分, 第二部分Reciever是接收者Fragment的一部分. </span><br><span class="line"> * Assignment dependency describes whether sender fragments depend <span class="keyword">on</span> receiver <span class="keyword">fragment</span>'s endpoint assignment <span class="keyword">for</span></span><br><span class="line"> * determining its parallelization and endpoint assignment and vice versa.</span><br><span class="line"> * 分配依赖描述了发送者Fragment是否依赖于接收者Fragment的节点分配任务, 以便于决定并行度和如何分配工作到节点上. 反过来一样.   </span><br><span class="line"> */</span><br><span class="line">public enum ParallelizationDependency &#123;</span><br><span class="line">  SENDER_DEPENDS_ON_RECEIVER, // Sending <span class="keyword">fragment</span> depends <span class="keyword">on</span> receiving <span class="keyword">fragment</span> <span class="keyword">for</span> parallelization</span><br><span class="line">  RECEIVER_DEPENDS_ON_SENDER, // Receiving <span class="keyword">fragment</span> depends <span class="keyword">on</span> sending <span class="keyword">fragment</span> <span class="keyword">for</span> parallelization (<span class="keyword">default</span> value).</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据PlanningSet构造依赖图:  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">final</span> <span class="built_in">Set</span>&lt;Wrapper&gt; leafFragments = constructFragmentDependencyGraph(planningSet);</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/** 根据Exchange的亲密程序分割两个fragments, 并且设置fragment的依赖关系.  </span><br><span class="line"> * Based on </span>the<span class="markdown"> affinity of </span>the<span class="markdown"> Exchange that separates two fragments, setup fragment dependencies.</span><br><span class="line"> * @return Returns </span>a<span class="markdown"> list of leaf fragments in fragment dependency graph. */</span></span></span><br><span class="line">private <span class="literal">static</span> <span class="built_in">Set</span>&lt;Wrapper&gt; constructFragmentDependencyGraph(PlanningSet planningSet) &#123;</span><br><span class="line">  <span class="comment">// Set up dependency of fragments based on the affinity of exchange that separates the fragments.</span></span><br><span class="line">  <span class="keyword">for</span>(Wrapper currentFragmentWrapper : planningSet) &#123;  <span class="comment">// PlanningSet包含了所有的Major Fragment组成的Wrapper,循环每一个Wrapper</span></span><br><span class="line">    ExchangeFragmentPair sendingExchange = currentFragmentWrapper.getNode().getSendingExchangePair();  <span class="comment">//每个MajorFragment要发送的目标</span></span><br><span class="line">    <span class="keyword">if</span> (sendingExchange != <span class="keyword">null</span>) &#123;  <span class="comment">// SendingExchange不为空的, 比如next, 而不是DAG图的第一个Fragment. 因为只有next才是发送者</span></span><br><span class="line">      ParallelizationDependency dependency = sendingExchange.getExchange().getParallelizationDependency();  <span class="comment">// 依赖关系记录在Exchange中, 而不是Fragment中</span></span><br><span class="line">      Wrapper receivingFragmentWrapper = planningSet.<span class="literal">get</span>(sendingExchange.getNode());  <span class="comment">// 目标节点, 实际上就是接收者了</span></span><br><span class="line">      <span class="comment">// 根据依赖关系, 判断要加到哪个Wrapper中, 实际上是哪个Fragment中. 因为Wrapper由MajorFragment组成.  </span></span><br><span class="line">      <span class="keyword">if</span> (dependency == ParallelizationDependency.RECEIVER_DEPENDS_ON_SENDER) &#123;     <span class="comment">// Receiver依赖Sender</span></span><br><span class="line">        receivingFragmentWrapper.addFragmentDependency(currentFragmentWrapper);   <span class="comment">// Receiver的依赖关系图中有当前Major Fragment</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dependency == ParallelizationDependency.SENDER_DEPENDS_ON_RECEIVER) &#123;  <span class="comment">// Sender依赖Reciever</span></span><br><span class="line">        currentFragmentWrapper.addFragmentDependency(receivingFragmentWrapper);   <span class="comment">// 当前节点刚好是Sender, 所以它依赖了接收者</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 上面的添加Fragment依赖图, 下面的Wrapper才可以获得依赖图, 来判断是否是叶子节点.  </span></span><br><span class="line">  <span class="comment">// Identify leaf fragments. Leaf fragments are fragments that have no other fragments depending on them for parallelization info. </span></span><br><span class="line">  <span class="comment">// First assume all fragments are leaf fragments. Go through the fragments one by one and  remove the fragment on which the current fragment depends on.</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Set</span>&lt;Wrapper&gt; roots = Sets.newHashSet();</span><br><span class="line">  <span class="keyword">for</span>(Wrapper w : planningSet) &#123;</span><br><span class="line">    roots.add(w);  <span class="comment">// 所有的Major Fragment</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(Wrapper wrapper : planningSet) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;Wrapper&gt; fragmentDependencies = wrapper.getFragmentDependencies();  <span class="comment">// 每个Major Fragment的依赖图</span></span><br><span class="line">    <span class="keyword">if</span> (fragmentDependencies != <span class="keyword">null</span> &amp;&amp; fragmentDependencies.size() &gt; <span class="number">0</span>) </span><br><span class="line">      <span class="keyword">for</span>(Wrapper dependency : fragmentDependencies)   <span class="comment">// 它的所有依赖者</span></span><br><span class="line">        <span class="keyword">if</span> (roots.contains(dependency)) </span><br><span class="line">          roots.remove(dependency);  <span class="comment">// 从roots中移除</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> roots;  <span class="comment">// 返回值是leaf fragments. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的方法roots返回的是leaf fragments. 在这之前首先对每个Major Fragments都设置了依赖图. 然后把非叶子节点从所有的Major中删除.<br>叶子节点的定义是: 没有依赖其他任何一个节点. 一旦一个节点有依赖某一个节点, 它就不是叶子节点了.  </p>
<p>获得叶子Fragment后, 对每一个叶子节点进行并行处理. 处理的时候先处理依赖的,然后才处理自己.所以也是递归的过程    </p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  // Start parallelizing <span class="keyword">from</span> leaf fragments 从叶子节点开始并行处理</span><br><span class="line">  <span class="keyword">for</span> (Wrapper wrapper : leafFragments) &#123;</span><br><span class="line">    parallelizeFragment(wrapper, planningSet, activeEndpoints);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// Helper method <span class="keyword">for</span> parallelizing a given <span class="keyword">fragment</span>. Dependent fragments are parallelized first before  parallelizing the given <span class="keyword">fragment</span>.</span><br><span class="line">private void parallelizeFragment(Wrapper <span class="keyword">fragment</span>Wrapper, PlanningSet planningSet, Collection<span class="variable">&lt;DrillbitEndpoint&gt;</span> activeEndpoints)  &#123;</span><br><span class="line">  // First parallelize fragments <span class="keyword">on</span> which this <span class="keyword">fragment</span> depends <span class="keyword">on</span>.</span><br><span class="line">  final List<span class="variable">&lt;Wrapper&gt;</span> <span class="keyword">fragment</span>Dependencies = <span class="keyword">fragment</span>Wrapper.getFragmentDependencies();</span><br><span class="line">  if (<span class="keyword">fragment</span>Dependencies != null &amp;&amp; <span class="keyword">fragment</span>Dependencies.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(Wrapper dependency : <span class="keyword">fragment</span>Dependencies) &#123;</span><br><span class="line">      parallelizeFragment(dependency, planningSet, activeEndpoints);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Fragment <span class="keyword">fragment</span> = <span class="keyword">fragment</span>Wrapper.getNode();</span><br><span class="line"></span><br><span class="line">  // Step <span class="number">1</span>: Find stats. Stats include various factors including cost of physical operators, parallelizability of work <span class="keyword">in</span> physical operator and affinity of physical operator <span class="keyword">to</span> certain nodes.</span><br><span class="line">  <span class="keyword">fragment</span>.getRoot().accept(new StatsCollector(planningSet), <span class="keyword">fragment</span>Wrapper);</span><br><span class="line"></span><br><span class="line">  // Step <span class="number">2</span>: Find the parallelization width of <span class="keyword">fragment</span></span><br><span class="line">  </span><br><span class="line">  List<span class="variable">&lt;DrillbitEndpoint&gt;</span> assignedEndpoints = findEndpoints(activeEndpoints, parallelizationInfo.getEndpointAffinityMap(), <span class="keyword">fragment</span>Wrapper.getWidth());</span><br><span class="line">  <span class="keyword">fragment</span>Wrapper.assignEndpoints(assignedEndpoints);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找到要分配的DrillBit后,就为Fragment分配计算节点 . 一个Fragment的Sending只有最多一个,可以有多个Receiver.   </p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void assignEndpoints(List<span class="tag">&lt;DrillbitEndpoint&gt;</span> assignedEndpoints)  &#123;</span><br><span class="line">  endpoints.addAll(assignedEndpoints);</span><br><span class="line"></span><br><span class="line">  // Set scan <span class="operator">and</span> store endpoints.</span><br><span class="line">  AssignEndpointsToScanAndStore visitor = new AssignEndpointsToScanAndStore();</span><br><span class="line">  <span class="keyword">node</span>.<span class="identifier"></span><span class="title">getRoot</span>().accept(visitor, endpoints);</span><br><span class="line"></span><br><span class="line">  // Set the endpoints for this (one at most) sending exchange.</span><br><span class="line">  if (<span class="keyword">node</span>.<span class="identifier"></span><span class="title">getSendingExchange</span>() != null) &#123;</span><br><span class="line">    <span class="keyword">node</span>.<span class="identifier"></span><span class="title">getSendingExchange</span>().setupSenders(majorFragmentId, endpoints);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Set the endpoints for each incoming exchange within this fragment.</span><br><span class="line">  for (ExchangeFragmentPair e : <span class="keyword">node</span>.<span class="identifier"></span><span class="title">getReceivingExchangePairs</span>()) &#123;</span><br><span class="line">    e.getExchange().setupReceivers(majorFragmentId, endpoints);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后基于上面的工作, 生成WorkUnit, QueryWorkUnit只是封装了rootOperator,rootFragment,fragments的对象.  注意下面是个双层循环,<br>外层的是对每个MajorFragment,内层则对每个MinorFragment. 如果不是根节点,则把创建的PlanFragment加入到fragments中.<br>PlanFragment一个重要的对象是FragmentHandle,顾名思义是Fragment的处理类, 它只封装了Major,Minor的FragmentID,以及查询ID.  </p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> QueryWorkUnit generateWorkUnit(OptionList <span class="keyword">options</span>, DrillbitEndpoint foremanNode, QueryId queryId,</span><br><span class="line">    PhysicalPlanReader reader, Fragment rootNode, PlanningSet planningSet, UserSession session, QueryContextInformation queryContextInfo) &#123;</span><br><span class="line">  List&lt;PlanFragment&gt; fragments = Lists.newArrayList();</span><br><span class="line">  PlanFragment rootFragment = <span class="keyword">null</span>;</span><br><span class="line">  FragmentRoot rootOperator = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// now we generate all the individual plan fragments and associated assignments. Note, we need all endpoints</span></span><br><span class="line">  <span class="comment">// assigned before we can materialize, so we start a new loop here rather than utilizing the previous one.</span></span><br><span class="line">  <span class="keyword">for</span> (Wrapper wrapper : planningSet) &#123;</span><br><span class="line">    Fragment node = wrapper.getNode();</span><br><span class="line">    <span class="keyword">final</span> PhysicalOperator physicalOperatorRoot = node.getRoot();</span><br><span class="line">    <span class="keyword">boolean</span> isRootNode = rootNode == node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a fragment is self driven if it doesn't rely on any other exchanges.</span></span><br><span class="line">    <span class="keyword">boolean</span> isLeafFragment = node.getReceivingExchangePairs().<span class="keyword">size</span>() == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a minorFragment for each major fragment.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> minorFragmentId = <span class="number">0</span>; minorFragmentId &lt; wrapper.getWidth(); minorFragmentId++) &#123;</span><br><span class="line">      IndexedFragmentNode iNode = <span class="keyword">new</span> IndexedFragmentNode(minorFragmentId, wrapper);</span><br><span class="line">      wrapper.resetAllocation();</span><br><span class="line">      PhysicalOperator op = physicalOperatorRoot.accept(Materializer.INSTANCE, iNode);</span><br><span class="line">      FragmentRoot root = (FragmentRoot) op;</span><br><span class="line">      FragmentHandle handle = FragmentHandle.newBuilder() <span class="comment">//</span></span><br><span class="line">          .setMajorFragmentId(wrapper.getMajorFragmentId()) <span class="comment">//</span></span><br><span class="line">          .setMinorFragmentId(minorFragmentId) <span class="comment">//</span></span><br><span class="line">          .setQueryId(queryId) <span class="comment">//</span></span><br><span class="line">          .build();</span><br><span class="line">      PlanFragment fragment = PlanFragment.newBuilder() <span class="comment">//</span></span><br><span class="line">          .setForeman(foremanNode) <span class="comment">//</span></span><br><span class="line">          .setFragmentJson(reader.writeJson(root)) <span class="comment">//</span></span><br><span class="line">          .setHandle(handle) <span class="comment">//</span></span><br><span class="line">          .setAssignment(wrapper.getAssignedEndpoint(minorFragmentId)) <span class="comment">//</span></span><br><span class="line">          .setLeafFragment(isLeafFragment) <span class="comment">//</span></span><br><span class="line">          .setContext(queryContextInfo)</span><br><span class="line">          .setMemInitial(wrapper.getInitialAllocation())<span class="comment">//</span></span><br><span class="line">          .setMemMax(wrapper.getMaxAllocation())</span><br><span class="line">          .setOptionsJson(reader.writeJson(<span class="keyword">options</span>))</span><br><span class="line">          .setCredentials(session.getCredentials())</span><br><span class="line">          .addAllCollector(CountRequiredFragments.getCollectors(root))</span><br><span class="line">          .build();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isRootNode) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Root fragment:\n &#123;&#125;"</span>, DrillStringUtils.unescapeJava(fragment.toString()));</span><br><span class="line">        rootFragment = fragment;</span><br><span class="line">        rootOperator = root;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">"Remote fragment:\n &#123;&#125;"</span>, DrillStringUtils.unescapeJava(fragment.toString()));</span><br><span class="line">        fragments.add(fragment);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> QueryWorkUnit(rootOperator, rootFragment, fragments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="提交并执行Fragments">提交并执行Fragments</h2><p>现在主线回到Foreman的runPhysicalPlan, 在提交Fragments执行前, 先添加了两个监听器到DrillbitContext对应的WorkBus和集群协调器.<br>然后设置RootFragment和非RootFragment. 设置根节点需要QueryWorkUnit的rootFragment和rootOperator.  非根节点只需要planFragments.  </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">runPhysicalPlan</span><span class="params">(<span class="keyword">final</span> PhysicalPlan plan)</span> <span class="keyword">throws</span> ExecutionSetupException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> QueryWorkUnit work = getQueryWorkUnit(plan);</span><br><span class="line">  <span class="keyword">final</span> List&lt;PlanFragment&gt; planFragments = work.getFragments();</span><br><span class="line">  <span class="keyword">final</span> PlanFragment rootPlanFragment = work.getRootFragment();</span><br><span class="line"></span><br><span class="line">  drillbitContext.getWorkBus().addFragmentStatusListener(queryId, queryManager.getFragmentStatusListener());</span><br><span class="line">  drillbitContext.getClusterCoordinator().addDrillbitStatusListener(queryManager.getDrillbitStatusListener());</span><br><span class="line">  logger.debug(<span class="string">"Submitting fragments to run."</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the root fragment first so we'll have incoming buffers available.</span></span><br><span class="line">  setupRootFragment(rootPlanFragment, work.getRootOperator());</span><br><span class="line">  setupNonRootFragments(planFragments);</span><br><span class="line">  drillbitContext.getAllocator().resetFragmentLimits(); <span class="comment">// TODO a global effect for this query?!?</span></span><br><span class="line"></span><br><span class="line">  moveToState(QueryState.RUNNING, <span class="keyword">null</span>);</span><br><span class="line">  logger.debug(<span class="string">"Fragments running."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
  </div>
  
    
<div class="copyright">
  <p><span>本文标题:</span><a href="/2015/07/15/2015-07-15-drill-fragments/">Apache Drill源码阅读(5) Fragment</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 任何忧伤,都抵不过世界的美丽 的个人博客">任何忧伤,都抵不过世界的美丽</a></p>
  <p><span>发布时间:</span>2015年07月15日 - 00时00分</p>
  <p><span>最后更新:</span>2015年12月02日 - 20时40分</p>
  <p>
    <span>原始链接:</span><a href="/2015/07/15/2015-07-15-drill-fragments/" title="Apache Drill源码阅读(5) Fragment">http://github.com/zqhxuyuan/2015/07/15/2015-07-15-drill-fragments/</a>
    <span class="btn" data-clipboard-text="原文: http://github.com/zqhxuyuan/2015/07/15/2015-07-15-drill-fragments/　　作者: 任何忧伤,都抵不过世界的美丽" title="点击复制文章链接">
        <i class="fa fa-clipboard"></i>
    </span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。</p>
  <script src="/js/clipboard.min.js"></script>
  <script> var clipboard = new Clipboard('.btn'); </script>
</div>
<style type="text/css">
  .copyright p .btn {
    margin-left: 1em;
  }
  .copyright:hover p .btn::after {
    content: "复制"
  }
  .copyright p .btn:hover {
      color: gray;
      cursor: pointer;
    };
</style>



<nav id="article-nav">
  
    <div id="article-nav-newer" class="article-nav-title">
      <a href="/2015/07/26/2015-07-26-drill-fragment-execute/">
        Apache Drill源码阅读(6) execute
      </a>
    </div>
  
  
    <div id="article-nav-older" class="article-nav-title">
      <a href="/2015/07/14/2015-07-14-drill-logical/">
        Apache Drill源码阅读(4) 逻辑计划
      </a>
    </div>
  
</nav>

  
</article>

<!-- 默认显示文章目录，在文章---前输入toc: false关闭目录 -->
<!-- Show TOC and tocButton in default, Hide TOC via putting "toc: false" before "---" at [post].md -->
<div id="toc" class="toc-article">
<strong class="toc-title">文章目录</strong>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Foreman-runPhysicalPlan运行物理计划"><span class="toc-number">1.</span> <span class="toc-text">Foreman.runPhysicalPlan运行物理计划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fragments_theory"><span class="toc-number">2.</span> <span class="toc-text">fragments theory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Major_Fragments"><span class="toc-number">3.</span> <span class="toc-text">Major Fragments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Receiver+Sender"><span class="toc-number">4.</span> <span class="toc-text">Receiver+Sender</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QueryWorkUnit"><span class="toc-number">5.</span> <span class="toc-text">QueryWorkUnit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Protobuf"><span class="toc-number">5.1.</span> <span class="toc-text">Protobuf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QueryContext_&_DrillbitContext"><span class="toc-number">5.2.</span> <span class="toc-text">QueryContext & DrillbitContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SimpleParallelizer"><span class="toc-number">5.3.</span> <span class="toc-text">SimpleParallelizer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PlanningSet+Wrapper"><span class="toc-number">5.4.</span> <span class="toc-text">PlanningSet+Wrapper</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#提交并执行Fragments"><span class="toc-number">6.</span> <span class="toc-text">提交并执行Fragments</span></a></li></ol>
</div>
<style type="text/css">
  .left-col .switch-btn {
    display: none;
  }
  .left-col .switch-area {
    display: none;
  }
</style>

<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">
<script type="text/javascript">
  var toc_button= document.getElementById("tocButton");
  var toc_div= document.getElementById("toc");
  /* Show or hide toc when click on tocButton.
  通过点击设置的按钮显示或者隐藏文章目录.*/
  toc_button.onclick=function(){
  if(toc_div.style.display=="none"){
  toc_div.style.display="block";
  toc_button.value="隐藏目录";
  document.getElementById("switch-btn").style.display="none";
  document.getElementById("switch-area").style.display="none";
  }
  else{
  toc_div.style.display="none";
  toc_button.value="显示目录";
  document.getElementById("switch-btn").style.display="block";
  document.getElementById("switch-area").style.display="block";
  }
  }
    if ($(".toc").length < 1) {
        $("#toc").css("display","none");
        $("#tocButton").css("display","none");
        $(".switch-btn").css("display","block");
        $(".switch-area").css("display","block");
    }
</script>


    <style>
        .toc {
            white-space: nowrap;
            overflow-x: hidden;
        }
    </style>

    <script>
        $(document).ready(function() {
            $(".toc li a").mouseover(function() {
                var title = $(this).attr('href');
                $(this).attr("title", title);
            });
        })
    </script>




<div class="share">
	<div class="bdsharebuttonbox">
	<a href="#" class="bds_more" data-cmd="more"></a>
	<a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
	<a href="#" class="bds_copy" data-cmd="copy" title="复制网址"></a>
	<a href="#" class="bds_mail" data-cmd="mail" title="通过邮件分享"></a>
	<a href="#" class="bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
	</div>
	<script>
	window._bd_share_config={
		"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
	</script>
</div>







    <style type="text/css">
    #scroll {
      display: none;
    }
    </style>
    <div class="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
    </div>


  
  
    
    <div  class="post-nav-button">
    <a href="/2015/07/26/2015-07-26-drill-fragment-execute/" title="上一篇: Apache Drill源码阅读(6) execute">
    <i class="fa fa-angle-left"></i>
    </a>
    <a href="/2015/07/14/2015-07-14-drill-logical/" title="下一篇: Apache Drill源码阅读(4) 逻辑计划">
    <i class="fa fa-angle-right"></i>
    </a>
    </div>
  



    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
        <script>
        var yiliaConfig = {
        fancybox: true,
        mathjax: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        open_in_new: false
        }
        </script>
        
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2016 任何忧伤,都抵不过世界的美丽
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的静态博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减双栏 Hexo 博客主题">Yelee</a> by MOxFIVE
        </div>
    </div>
    <div class="visit">
      <span id="busuanzi_container_site_pv" style='display:none'>
        <span id="site-visit" >本站到访数: 
        <span id="busuanzi_value_site_uv"></span>
        </span>
      </span>
      <span id="busuanzi_container_page_pv" style='display:none'>
        <span id="page-visit">, 本页阅读量: 
        <span id="busuanzi_value_page_pv"></span>
        </span>
      </span>
    </div>
  </div>
</footer>
    </div>
    

<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>

<script>
  var backgroundnum = 5;
  var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));

  $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
</script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
<a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
<a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>